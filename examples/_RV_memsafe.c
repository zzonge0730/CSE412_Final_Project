#include "_RV_memsafe.h"
#define __RV_memerr_action

/*===----------------------------------------------------------------------===//
//
//  This file is automatically generated for data structures.
//
//===----------------------------------------------------------------------===*/

/*Addresses of predefined status nodes with auto-deallocation.
  Their lifetime is the entire run of the program.*/
__RV_stat_node *__RV_function_sa;
__RV_stat_node *__RV_global_sa;
__RV_stat_node *__RV_static_sa;
__RV_stat_node *__RV_library_sa;

#include <stdio.h>

/*Count of memory safety errors.*/
size_t __RV_error_count = 0;

void __RV_global_clear_code(void);

/*Print the runtime error count.*/
void __RV_print_error_count(void)
{
  __RV_global_clear_code();
  if(__RV_error_count == 1)
    fprintf(stderr, "1 error generated.\n");
  if(__RV_error_count >  1)
    fprintf(stderr, "%lu errors generated.\n", __RV_error_count);
}
/*===----------------------------------------------------------------------===//
//
//  This file is automatically generated for metadata.
//
//===----------------------------------------------------------------------===*/

/*===----------------------------- stat_node ------------------------------===*/
__RV_stat_node *__RV_stat_node_create(__RV_status stat, size_t count);
__RV_status     __RV_stat_node_get_stat(const __RV_stat_node *snda);
size_t            __RV_stat_node_get_count(const __RV_stat_node *snda);
unsigned          __RV_stat_node_dec(__RV_stat_node *snda);
void              __RV_stat_node_inc(__RV_stat_node *snda);
/*===----------------------------- pmd ------------------------------------===*/
__RV_pmd       *__RV_pmd_create(__RV_ptr_addr ptra, __RV_stat_node *snda,
                        __RV_status stat, const void *base, const void *bound);
__RV_pmd       *__RV_pmd_create_null(__RV_ptr_addr ptra);
void              __RV_pmd_init_null(__RV_pmd *pmd, __RV_ptr_addr ptra);
void              __RV_pmd_free(__RV_pmd *pmd);
void              __RV_pmd_free_null_ptr(__RV_pmd *pmd);
unsigned          __RV_pmd_is_null(const __RV_pmd *pmd);
const void       *__RV_pmd_get_base(const __RV_pmd *pmd);
const void       *__RV_pmd_get_bound(const __RV_pmd *pmd);
__RV_stat_node *__RV_pmd_get_snda(const __RV_pmd *pmd);
__RV_status     __RV_pmd_get_stat(const __RV_pmd *pmd);
size_t            __RV_pmd_get_count(const __RV_pmd *pmd);
void              __RV_pmd_print(const __RV_pmd *pmd);
#if defined __RV_use_ext_cas
unsigned          __RV_pmd_is_regular(const __RV_pmd *pmd);
unsigned          __RV_pmd_is_dummy(const __RV_pmd *pmd);
#endif
void              __RV_pmd_set_base(__RV_pmd *pmd, const void *base);
void              __RV_pmd_set_bound(__RV_pmd *pmd, const void *bound);
void              __RV_pmd_dc_snda(__RV_pmd *pmd);
void              __RV_pmd_c_snda(__RV_pmd *pmd, __RV_stat_node *snda);
void              __RV_pmd_set_stat(__RV_pmd *pmd, __RV_status stat);
__RV_pmd       *__RV_pmd_set(__RV_pmd *pmd, __RV_stat_node *snda,
                        __RV_status stat, const void *base, const void *bound);
void             *__RV_pmd_set_ret(__RV_pmd *pmd, __RV_stat_node *snda,
                        __RV_status stat, const void *base, const void *bound, const void *ret);
void              __RV_pmd_set_null(__RV_pmd *pmd);
__RV_pmd       *__RV_pmd_cp_pmd(__RV_pmd *pmd, const __RV_pmd *pmd2);
void             *__RV_pmd_cp_pmd_ret(__RV_pmd *pmd, const __RV_pmd *pmd2, const void *ret);
__RV_pmd       *__RV_pmd_cp_fmd_pmd(__RV_pmd *pmd, const __RV_fmd_pmd *fpmd);
/*===----------------------------- fmd_pmd --------------------------------===*/
unsigned          __RV_fmd_pmd_is_null(const __RV_fmd_pmd *fpmd);
const void       *__RV_fmd_pmd_get_base(const __RV_fmd_pmd *fpmd);
const void       *__RV_fmd_pmd_get_bound(const __RV_fmd_pmd *fpmd);
__RV_stat_node *__RV_fmd_pmd_get_snda(const __RV_fmd_pmd *fpmd);
__RV_status     __RV_fmd_pmd_get_stat(const __RV_fmd_pmd *fpmd);
void              __RV_fmd_pmd_dc_snda(__RV_fmd_pmd *fpmd);
void              __RV_fmd_pmd_c_snda(__RV_fmd_pmd *fpmd, __RV_stat_node *snda);
void              __RV_fmd_pmd_set(__RV_fmd_pmd *fpmd, __RV_stat_node *snda,
                        __RV_status stat, const void *base, const void *bound);
void              __RV_fmd_pmd_set_null(__RV_fmd_pmd *fpmd);
void              __RV_fmd_pmd_cp_pmd(__RV_fmd_pmd *fpmd, const __RV_pmd *pmd);
/*===----------------------------- fmd ------------------------------------===*/
__RV_fmd     *__RV_fmd_create(__RV_func_addr func, unsigned char capacity);
void            __RV_fmd_free_pmds(__RV_fmd *fmd);
void            __RV_fmd_free(__RV_fmd *fmd);
__RV_fmd_pmd *__RV_fmd_get_fmd_pmd(const __RV_fmd *fmd, unsigned char i);
#if defined __RV_use_ext_cas
unsigned        __RV_fmd_is_regular(const __RV_fmd *fmd);
unsigned        __RV_fmd_is_dummy(const __RV_fmd *fmd);
#endif
void            __RV_fmd_dc_snda(__RV_fmd *fmd);
void            __RV_fmd_set_null(__RV_fmd *fmd);
void            __RV_fmd_cp_pmd(__RV_fmd *fmd, unsigned char i, const __RV_pmd *pmd);
void            __RV_fmd_resize_pmds(__RV_fmd *fmd, unsigned char new_capacity,
                     unsigned char clear);

#define __RV_atomic_fetch_and_inc(p) __sync_fetch_and_add(p, 1)

#define __RV_atomic_fetch_and_dec(p) __sync_fetch_and_sub(p, 1)

#define __RV__CAS(p, old, new) __sync_bool_compare_and_swap(p, old, new)

/*===----------------------------- stat_node ------------------------------===*/

#include <stdlib.h>

/*Create a new status node.*/
 inline
__RV_stat_node *__RV_stat_node_create(__RV_status stat, size_t count)
{
  __RV_stat_node *snda = (__RV_stat_node *)malloc(sizeof(__RV_stat_node));
  if(snda == NULL) return NULL;
  snda->stat  = stat;
  snda->count = count;
  return snda;
}

 inline
__RV_status __RV_stat_node_get_stat(const __RV_stat_node *snda)
{
  if(snda == NULL) return __RV_invalid;
  return snda->stat;
}

 inline
size_t __RV_stat_node_get_count(const __RV_stat_node *snda)
{
  if(snda == NULL) return 0;
  return snda->count;
}

/*Decrease the count of a status node. If the count becomes 0, it is freed.
  If there is a memory leak, then it returns 1. Otherwise, it returns 0.*/
 inline
unsigned __RV_stat_node_dec(__RV_stat_node *snda)
{
  unsigned ret = 0;
  if(snda == NULL)
    return 0;
  if(snda->count == 0)
    return 0;
  if(snda->count == 1)
  {
    if(snda->stat == __RV_heap) ret = 1;
    free(snda);
  }
  else
  {
#if !defined __RV_use_ext_cas
    snda->count--;
#else
    __RV_atomic_fetch_and_dec(&snda->count);
#endif
  }
  return ret;
}

/*Increase the count of a status node.*/
 inline
void __RV_stat_node_inc(__RV_stat_node *snda)
{
  if(snda == NULL) return;
#if !defined __RV_use_ext_cas
  snda->count++;
#else
  __RV_atomic_fetch_and_inc(&snda->count);
#endif
}

/*===----------------------------- pmd ------------------------------------===*/

#if defined __RV_use_ext_cas
void            __RV_freelist_insert_pmd(__RV_pmd *pmd);
void            __RV_freelist_insert_fmd(__RV_fmd *fmd);
__RV_so_key_t __RV_so_regularkey(const void *p);
__RV_so_key_t __RV_so_dummykey(size_t index);
#endif

/*Create a new pointer metadata.
  If snda is NULL, then a new status node is created from stat.
  If stat is invalid, then its snda is set to NULL.*/
 inline
__RV_pmd *__RV_pmd_create(__RV_ptr_addr ptra, __RV_stat_node *snda,
                 __RV_status stat, const void *base, const void *bound)
{
  __RV_pmd *pmd = __RV_pmd_create_null(ptra);
  __RV_pmd_set(pmd, snda, stat, base, bound);
  return pmd;
}

/*Create a new pointer metadata whose snda, base, bound and next are NULL.*/
 inline
__RV_pmd *__RV_pmd_create_null(__RV_ptr_addr ptra)
{
  __RV_pmd *pmd = (__RV_pmd *)malloc(sizeof(__RV_pmd));
  if(pmd == NULL) return NULL;
  __RV_pmd_init_null(pmd, ptra);
  return pmd;
}

 inline
void __RV_pmd_init_null(__RV_pmd *pmd, __RV_ptr_addr ptra)
{
  if(!pmd) return;
  pmd->base  = NULL;
  pmd->bound = NULL;
  pmd->snda  = NULL;
#if defined __RV_use_trie
  if(ptra == NULL) pmd->pmdflag = 2;
  else pmd->pmdflag = 1;
#elif defined __RV_use_hashtable
  pmd->ptra = ptra;
  pmd->next = NULL;
#if defined __RV_use_ext_cas
  pmd->so_key = __RV_so_regularkey(ptra);
#endif
#endif
}

/*Free a pointer metadata.*/
 inline
void __RV_pmd_free(__RV_pmd *pmd)
{
  if(pmd == NULL) return;
  __RV_pmd_dc_snda(pmd);
#if defined __RV_use_ext_cas
  __RV_freelist_insert_pmd(pmd);
#else
  free(pmd);
#endif
}

/*Free a pointer metadata only if its member "ptra" is NULL.*/
 inline
void __RV_pmd_free_null_ptr(__RV_pmd *pmd)
{
  if(pmd == NULL) return;
#if defined __RV_use_trie
  if(pmd->pmdflag == 2)
    __RV_pmd_free(pmd);
#elif defined __RV_use_hashtable
  if(pmd->ptra == NULL)
    __RV_pmd_free(pmd);
#endif
}

 inline
unsigned __RV_pmd_is_null(const __RV_pmd *pmd)
{
  if(pmd == NULL) return 1;
  if(pmd->snda == NULL && pmd->base == NULL && pmd->bound == NULL)
    return 1;
  return 0;
}

 inline
const void *__RV_pmd_get_base(const __RV_pmd *pmd)
{
  if(pmd == NULL) return NULL;
  return pmd->base;
}

 inline
const void *__RV_pmd_get_bound(const __RV_pmd *pmd)
{
  if(pmd == NULL) return NULL;
  return pmd->bound;
}

 inline
__RV_stat_node *__RV_pmd_get_snda(const __RV_pmd *pmd)
{
  if(pmd == NULL) return NULL;
  return pmd->snda;
}

 inline
__RV_status __RV_pmd_get_stat(const __RV_pmd *pmd)
{
  if(pmd == NULL) return __RV_invalid;
  return __RV_stat_node_get_stat(pmd->snda);
}

 inline
size_t __RV_pmd_get_count(const __RV_pmd *pmd)
{
  if(pmd == NULL) return 0;
  return __RV_stat_node_get_count(pmd->snda);
}

/*Print a pmd.*/
 inline
void __RV_pmd_print(const __RV_pmd *pmd)
{
  if(!pmd)
    printf("The pmd does not exist.\n");
  else
  {
    printf("The pmd is [%p, %p), status = ",
           pmd->base, pmd->bound);
    if(!pmd->snda)
      printf("(null)\n");
    else
      printf("(%d, %lu)\n", pmd->snda->stat, pmd->snda->count);
  }
}

#if defined __RV_use_ext_cas
/*Decide if a pmd is a regular node, i.e., whether the LSB of its so_key is 1.*/
 inline
unsigned __RV_pmd_is_regular(const __RV_pmd *pmd)
{
  if(pmd == NULL) return 0;
  return pmd->so_key & 1;
}

/*Decide if a pmd is a dummy node, i.e., whether the LSB of its so_key is 0.*/
 inline
unsigned __RV_pmd_is_dummy(const __RV_pmd *pmd)
{
  if(pmd == NULL) return 0;
  return (pmd->so_key & 1) == 0;
}
#endif

/*Set the base of a pointer metadata.
  If pmd does not exist, do nothing.*/
 inline
void __RV_pmd_set_base(__RV_pmd *pmd, const void *base)
{
  if(pmd == NULL) return;
  pmd->base = base;
}

/*Set the bound of a pointer metadata.
  If pmd does not exist, do nothing.*/
 inline
void __RV_pmd_set_bound(__RV_pmd *pmd, const void *bound)
{
  if(pmd == NULL) return;
  pmd->bound = bound;
}

/*Disconnect a pointer metadata from its status node.*/
 inline
void __RV_pmd_dc_snda(__RV_pmd *pmd)
{
  unsigned char mem_leak;
#if defined __RV_ms_no_self_leak
  const void *p; const __RV_pmd *ppmd;
#endif
  if(pmd == NULL) return;

  /*check memory leaks.*/
  mem_leak = __RV_stat_node_dec(pmd->snda);

#if defined __RV_ms_no_self_leak
  /*check memory leaks on self-pointers.*/
  if(pmd->base != NULL && pmd->bound != NULL && pmd->snda != NULL &&
     pmd->snda->stat == __RV_heap && pmd->snda->count == 1)
  {
    for(p = pmd->base; p < pmd->bound; p = p + sizeof(void *))
    {
      ppmd = __RV_pmd_tbl_lookup((__RV_ptr_addr)p);
      if(ppmd && ppmd->base != NULL && ppmd->bound != NULL &&
         ppmd != pmd && ppmd->snda == pmd->snda)
      {
        mem_leak = 1;
        break;
      }
    }
  }
#endif

  if(mem_leak == 1)
  {
#if !defined __RV_ms_no_check
#if defined _RV_NORANDOM
    fprintf(stderr, "error: memory leak detected.\n");
#else
#if defined __RV_use_trie
    fprintf(stderr, "error: memory leak of the block [%p, %p).\n",
            pmd->base, pmd->bound);
#elif defined __RV_use_hashtable
    fprintf(stderr, "error: memory leak of the block [%p, %p), "
            "the last pointer's address is %p.\n",
            pmd->base, pmd->bound, pmd->ptra);
#endif
#endif
    __RV_error_count++;
    __RV_memerr_action
#endif
  }

  pmd->snda = NULL;
}

/*Connect a pointer metadata to a given status node.*/
 inline
void __RV_pmd_c_snda(__RV_pmd *pmd, __RV_stat_node *snda)
{
  if(pmd == NULL || pmd->snda == snda) return;
  __RV_pmd_dc_snda(pmd);
  pmd->snda = snda;
  __RV_stat_node_inc(snda);
}

/*Set the stat of a pointer metadata.
  If pmd->snda does not exist, do nothing.*/
 inline
void __RV_pmd_set_stat(__RV_pmd *pmd, __RV_status stat)
{
  if(pmd == NULL || pmd->snda == NULL) return;
  pmd->snda->stat = stat;
}

/*Set the snda, base and bound of a pointer metadata.
  If snda is NULL, then a new status node is created from stat.
  If stat is invalid, then its snda is set to NULL.*/
 inline
__RV_pmd *__RV_pmd_set(__RV_pmd *pmd, __RV_stat_node *snda,
        __RV_status stat, const void *base, const void *bound)
{
  if(pmd == NULL) return pmd;
  /* Note: To report base and bound for memory leak,
     snda must be set before setting base and bound. */
  /*set status*/
  if(snda != NULL)
    __RV_pmd_c_snda(pmd, snda);
  else
  {
    __RV_pmd_dc_snda(pmd);
    if(stat != __RV_invalid)
      pmd->snda = __RV_stat_node_create(stat, 1);
  }
  /*set base and bound*/
  pmd->base  = base;
  pmd->bound = bound;
#if defined __RV_use_trie
  if (pmd->pmdflag == 0) pmd->pmdflag = 1;
#endif
  return pmd;
}

 inline
void *__RV_pmd_set_ret(__RV_pmd *pmd, __RV_stat_node *snda,
        __RV_status stat, const void *base, const void *bound, const void *ret)
{
  __RV_pmd_set(pmd, snda, stat, base, bound);
  return (void *)ret;
}

/*Set the snda, base and bound of a pointer metadata to NULL.*/
 inline
void __RV_pmd_set_null(__RV_pmd *pmd)
{
  if(pmd == NULL) return;
  /* Note: To report base and bound for memory leak,
     snda must be set before setting base and bound. */
  __RV_pmd_dc_snda(pmd);
  pmd->base  = NULL;
  pmd->bound = NULL;
#if defined __RV_use_trie
  if (pmd->pmdflag == 0) pmd->pmdflag = 1;
#endif
}

/*Copy the snda, base and bound from a pmd.*/
 inline
__RV_pmd *__RV_pmd_cp_pmd(__RV_pmd *pmd, const __RV_pmd *pmd2)
{
  if(pmd == NULL) return pmd;
  if(pmd2 == NULL)
    __RV_pmd_set_null(pmd);
  else
  {
    /* Note: To report base and bound for memory leak,
       snda must be set before setting base and bound. */
    __RV_pmd_c_snda(pmd, pmd2->snda);
    pmd->base  = pmd2->base;
    pmd->bound = pmd2->bound;
#if defined __RV_use_trie
    if (pmd->pmdflag == 0) pmd->pmdflag = 1;
#endif
  }
  return pmd;
}

 inline
void *__RV_pmd_cp_pmd_ret(__RV_pmd *pmd, const __RV_pmd *pmd2, const void *ret)
{
  __RV_pmd_cp_pmd(pmd, pmd2);
  return (void *)ret;
}

/*Copy the snda, base and bound from a pmd in function pointer metadata.*/
 inline
__RV_pmd *__RV_pmd_cp_fmd_pmd(__RV_pmd *pmd, const __RV_fmd_pmd *fpmd)
{
  if(pmd == NULL) return pmd;
  if(fpmd == NULL)
    __RV_pmd_set_null(pmd);
  else
  {
    /* Note: To report base and bound for memory leak,
       snda must be set before setting base and bound. */
    __RV_pmd_c_snda(pmd, fpmd->snda);
    pmd->base  = fpmd->base;
    pmd->bound = fpmd->bound;
#if defined __RV_use_trie
    if (pmd->pmdflag == 0) pmd->pmdflag = 1;
#endif
  }
  return pmd;
}

/*===----------------------------- fmd_pmd --------------------------------===*/

 inline
unsigned __RV_fmd_pmd_is_null(const __RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return 1;
  if(fpmd->snda == NULL && fpmd->base == NULL && fpmd->bound == NULL)
    return 1;
  return 0;
}

 inline
const void *__RV_fmd_pmd_get_base(const __RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return NULL;
  return fpmd->base;
}

 inline
const void *__RV_fmd_pmd_get_bound(const __RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return NULL;
  return fpmd->bound;
}

 inline
__RV_stat_node *__RV_fmd_pmd_get_snda(const __RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return NULL;
  return fpmd->snda;
}

 inline
__RV_status __RV_fmd_pmd_get_stat(const __RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return __RV_invalid;
  return __RV_stat_node_get_stat(fpmd->snda);
}

/*Disconnect a pmd in function pointer metadata from its status node.*/
 inline
void __RV_fmd_pmd_dc_snda(__RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return;

  /*check memory leaks.*/
  if(__RV_stat_node_dec(fpmd->snda) == 1)
  {
#if !defined __RV_ms_no_check
#if defined _RV_NORANDOM
    fprintf(stderr, "error: memory leak detected.\n");
#else
    fprintf(stderr, "error: memory leak of the block [%p, %p), "
            "the last pointer is a function parameter.\n",
            fpmd->base, fpmd->bound);
#endif
    __RV_error_count++;
    __RV_memerr_action
#endif
  }

  fpmd->snda = NULL;
}

/*Connect a pmd in function pointer metadata to a given status node.*/
 inline
void __RV_fmd_pmd_c_snda(__RV_fmd_pmd *fpmd, __RV_stat_node *snda)
{
  if(fpmd == NULL || fpmd->snda == snda) return;
  __RV_fmd_pmd_dc_snda(fpmd);
  fpmd->snda = snda;
  __RV_stat_node_inc(snda);
}

/*Set the snda, base and bound of a pmd in function pointer metadata.
  If snda is NULL, then a new status node is created from stat.
  If stat is invalid, then its snda is set to NULL.*/
 inline
void __RV_fmd_pmd_set(__RV_fmd_pmd *fpmd, __RV_stat_node *snda,
        __RV_status stat, const void *base, const void *bound)
{
  if(fpmd == NULL) return;
  /* Note: To report base and bound for memory leak,
     snda must be set before setting base and bound. */
  /*set status*/
  if(snda != NULL)
    __RV_fmd_pmd_c_snda(fpmd, snda);
  else
  {
    __RV_fmd_pmd_dc_snda(fpmd);
    if(stat != __RV_invalid)
      fpmd->snda = __RV_stat_node_create(stat, 1);
  }
  /*set base and bound*/
  fpmd->base  = base;
  fpmd->bound = bound;
}

/*Set the snda, base and bound of a pmd in function pointer metadata to NULL.*/
 inline
void __RV_fmd_pmd_set_null(__RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL) return;
  /* Note: To report base and bound for memory leak,
     snda must be set before setting base and bound. */
  __RV_fmd_pmd_dc_snda(fpmd);
  fpmd->base  = NULL;
  fpmd->bound = NULL;
}

/*Copy the snda, base and bound from a pointer metadata.*/
 inline
void __RV_fmd_pmd_cp_pmd(__RV_fmd_pmd *fpmd, const __RV_pmd *pmd)
{
  if(fpmd == NULL) return;
  if(pmd == NULL)
    __RV_fmd_pmd_set_null(fpmd);
  else
  {
    /* Note: To report base and bound for memory leak,
       snda must be set before setting base and bound. */
    __RV_fmd_pmd_c_snda(fpmd, pmd->snda);
    fpmd->base  = pmd->base;
    fpmd->bound = pmd->bound;
  }
}

/*===----------------------------- fmd ------------------------------------===*/

#if defined __RV_use_ext_cas
unsigned __RV_get_thread_index(void);
#endif

/*Create a function pointer metadata with the given capacity.*/

__RV_fmd *__RV_fmd_create(__RV_func_addr func, unsigned char capacity)
{
  __RV_fmd *fmd = (__RV_fmd *)malloc(sizeof(__RV_fmd));
  unsigned char i;

  if(fmd == NULL) return NULL;

  fmd->pmds = (__RV_fmd_pmd *)malloc(capacity*sizeof(__RV_fmd_pmd));
  if(fmd->pmds == NULL)
  {
    free(fmd);
    return NULL;
  }
  for(i = 0; i < capacity; i++)
  {
    fmd->pmds[i].base  = NULL;
    fmd->pmds[i].bound = NULL;
    fmd->pmds[i].snda  = NULL;
  }
  fmd->capacity = capacity;
  fmd->func = func;
  fmd->next = NULL;
#if defined __RV_use_ext_cas
  fmd->t_idx = __RV_get_thread_index();
  fmd->so_key = __RV_so_regularkey(func);
#endif
  return fmd;
}

/*Free all the pointer metadata in a function pointer metadata.*/

void __RV_fmd_free_pmds(__RV_fmd *fmd)
{
  unsigned char i;
  if(fmd == NULL || fmd->pmds == NULL) return;
  for(i = 0; i < fmd->capacity; i++)
    __RV_fmd_pmd_dc_snda(fmd->pmds + i);
  free(fmd->pmds);
  fmd->pmds = NULL;
  fmd->capacity = 0;
}

/*Free a function pointer metadata.*/
 inline
void __RV_fmd_free(__RV_fmd *fmd)
{
  if(fmd == NULL) return;
  __RV_fmd_free_pmds(fmd);
#if defined __RV_use_ext_cas
  __RV_freelist_insert_fmd(fmd);
#else
  free(fmd);
#endif
}

/*Get the i-th pointer metadata in a function pointer metadata.*/
 inline
__RV_fmd_pmd *__RV_fmd_get_fmd_pmd(const __RV_fmd *fmd, unsigned char i)
{
  if(fmd == NULL || fmd->pmds == NULL || i >= fmd->capacity)
    return NULL;
  return fmd->pmds + i;
}

#if defined __RV_use_ext_cas
/*Decide if a fmd is a regular node, i.e., whether the LSB of its so_key is 1.*/
 inline
unsigned __RV_fmd_is_regular(const __RV_fmd *fmd)
{
  if(fmd == NULL) return 0;
  return fmd->so_key & 1;
}

/*Decide if a fmd is a dummy node, i.e., whether the LSB of its so_key is 0.*/
 inline
unsigned __RV_fmd_is_dummy(const __RV_fmd *fmd)
{
  if(fmd == NULL) return 0;
  return (fmd->so_key & 1) == 0;
}
#endif

/*Disconnect all pmds in function pointer metadata from their status nodes.*/

void __RV_fmd_dc_snda(__RV_fmd *fmd)
{
  unsigned char i;
  if(fmd == NULL || fmd->pmds == NULL) return;
  for(i = 0; i < fmd->capacity; i++)
    __RV_fmd_pmd_dc_snda(fmd->pmds + i);
}

/*Set the snda, base and bound of all pmds in function pointer metadata to NULL.*/
 inline
void __RV_fmd_set_null(__RV_fmd *fmd)
{
  unsigned char i;
  if(fmd == NULL || fmd->pmds == NULL) return;
  for(i = 0; i < fmd->capacity; i++)
    __RV_fmd_pmd_set_null(fmd->pmds + i);
}

/*Copy the snda, base and bound from a pointer metadata,
  to the i-th pointer metadata in a function pointer metadata.*/
 inline
void __RV_fmd_cp_pmd(__RV_fmd *fmd, unsigned char i, const __RV_pmd *pmd)
{
  __RV_fmd_pmd_cp_pmd(__RV_fmd_get_fmd_pmd(fmd, i), pmd);
}

/*Resize the table of pmds in a function pointer metadata to a new capacity.
  If clear is 0, then the old pointer metadata will not be cleared,
  i.e., reused by the new table of pointer metadata.*/

void __RV_fmd_resize_pmds(__RV_fmd *fmd, unsigned char new_capacity,
                            unsigned char clear)
{
  unsigned char i;
  __RV_fmd_pmd *new_pmds;
  if(fmd->capacity >= new_capacity) /*decrease capacity, reuse old pmds*/
  {
    if(clear != 0)
      for(i = 0; i < new_capacity; i++)
        __RV_fmd_pmd_set_null(fmd->pmds + i);
    for(i = new_capacity; i < fmd->capacity; i++)
      __RV_fmd_pmd_set_null(fmd->pmds + i);
  }
  else /*fmd->capacity < new_capacity, i.e., increase capacity*/
  {
    new_pmds = (__RV_fmd_pmd *)malloc(new_capacity*sizeof(__RV_fmd_pmd));
    if(clear != 0)
    {
      for(i = 0; i < new_capacity; i++)
      {
        new_pmds[i].base  = NULL;
        new_pmds[i].bound = NULL;
        new_pmds[i].snda  = NULL;
      }
    }
    else /*do not clear, i.e., reuse old pmds*/
    {
      for(i = 0; i < fmd->capacity; i++)
      {
        new_pmds[i].base  = fmd->pmds[i].base;
        new_pmds[i].bound = fmd->pmds[i].bound;
        new_pmds[i].snda  = fmd->pmds[i].snda;
      }
      for(     ; i < new_capacity; i++)
      {
        new_pmds[i].base  = NULL;
        new_pmds[i].bound = NULL;
        new_pmds[i].snda  = NULL;
      }
    }
    free(fmd->pmds);
    fmd->pmds = new_pmds;
    fmd->capacity = new_capacity;
  } /* end if(fmd->capacity < new_capacity) */
}
/*===----------------------------------------------------------------------===//
//
//  This file is automatically generated for tries.
//
//===----------------------------------------------------------------------===*/

/*===----------------------------- trie -----------------------------------===*/
void          __RV_trie_get_index(__RV_ptr_addr ptra,
                   size_t *primary_index, size_t *secondary_index);
__RV_pmd  **__RV_trie_create(void);
__RV_pmd   *__RV_trie_create_secondary(void);
__RV_pmd   *__RV_trie_find_pmd(__RV_pmd **tbl, __RV_ptr_addr ptra);
__RV_pmd   *__RV_trie_insert_pmd_ptr(__RV_pmd **tbl, __RV_ptr_addr ptra);
int           __RV_trie_remove_pmd(__RV_pmd **tbl, __RV_ptr_addr ptra);
__RV_pmd ***__RV_trie_get_trie_ref_pmd(void);
__RV_pmd  **__RV_trie_get_trie_pmd(void);

/*===----------------------------- trie -----------------------------------===*/

#if defined _DEFAULT_SOURCE
#include <sys/mman.h>
#else
#include <stdlib.h>
#endif
#include <assert.h>

/* The primary table has 2^23 entries. */
const size_t _RV_TRIE_PRIMARY_ENTRIES = 0x800000;
/* Each secondary table has 2^22 entries. */
const size_t _RV_TRIE_SECONDARY_ENTRIES = 0x400000;
#if defined _DEFAULT_SOURCE
#if defined __APPLE__
#define _RV_TRIE_MMAP_FLAGS (MAP_ANON|MAP_NORESERVE|MAP_PRIVATE)
#else
#define _RV_TRIE_MMAP_FLAGS (MAP_ANONYMOUS|MAP_NORESERVE|MAP_PRIVATE)
#endif
#endif

/*Get the primary and secondary indices of a pointer address in a trie.*/
 inline
void __RV_trie_get_index(__RV_ptr_addr ptra,
           size_t *primary_index, size_t *secondary_index)
{
  size_t key = (size_t) ptra;
  *primary_index = ((key >> 25) & 0x7fffff);
  *secondary_index = ((key >> 3) & 0x3fffff);
}

 inline
__RV_pmd **__RV_trie_create(void)
{
  size_t len = _RV_TRIE_PRIMARY_ENTRIES * sizeof(__RV_pmd *);
#if defined _DEFAULT_SOURCE
  __RV_pmd **trie_primary =
    mmap(0, len, PROT_READ|PROT_WRITE, _RV_TRIE_MMAP_FLAGS, -1, 0);
  assert(trie_primary != (void *)-1);
#else
  __RV_pmd **trie_primary = malloc(len);
  assert(trie_primary != NULL);
#endif
  return trie_primary;
}

 inline
__RV_pmd *__RV_trie_create_secondary(void)
{
  size_t len = _RV_TRIE_SECONDARY_ENTRIES * sizeof(__RV_pmd);
#if defined _DEFAULT_SOURCE
  __RV_pmd *trie_secondary =
    mmap(0, len, PROT_READ|PROT_WRITE, _RV_TRIE_MMAP_FLAGS, -1, 0);
  assert(trie_secondary != (void*)-1);
#else
  __RV_pmd *trie_secondary = malloc(len);
  assert(trie_secondary != NULL);
#endif
  return trie_secondary;
}

/*Find the pmd of the given pointer address in the trie.
  If the pmd does not exist, it returns NULL.*/
 inline
__RV_pmd *__RV_trie_find_pmd(__RV_pmd **tbl, __RV_ptr_addr ptra)
{
  size_t primary_index;
  size_t secondary_index;
  __RV_pmd *secondary_table;

  __RV_trie_get_index(ptra, &primary_index, &secondary_index);
  secondary_table = tbl[primary_index];
  if(secondary_table == NULL) return NULL;
  if(secondary_table[secondary_index].pmdflag == 0) return NULL;
  return secondary_table + secondary_index;
}

/*Insert a pmd of the given pointer address to the trie.
  If the pmd of the given pointer address already exists,
  the existing pmd will be returned.*/
 inline
__RV_pmd *__RV_trie_insert_pmd_ptr(__RV_pmd **tbl, __RV_ptr_addr ptra)
{
  size_t primary_index;
  size_t secondary_index;
  __RV_pmd *secondary_table;

  __RV_trie_get_index(ptra, &primary_index, &secondary_index);
  secondary_table = tbl[primary_index];
  if(secondary_table == NULL)
  {
    secondary_table = __RV_trie_create_secondary();
    tbl[primary_index] = secondary_table;
  }
  secondary_table[secondary_index].pmdflag = 1;
  return secondary_table + secondary_index;
}

/*Remove (set null) the pmd of the given pointer address from the trie.
  If a pmd is removed (set null), it returns 1. Otherwise, it returns 0.*/
 inline
int __RV_trie_remove_pmd(__RV_pmd **tbl, __RV_ptr_addr ptra)
{
  __RV_pmd *pmd = __RV_trie_find_pmd(tbl, ptra);
  /*not found*/
  if(NULL == pmd)
    return 0;
  /*found: set the existing pmd to NULL*/
  __RV_pmd_set_null(pmd);
  pmd->pmdflag = 0;
  return 1;
}

/*Get the reference of the trie storing pmds.
  If it does not exist, an empty trie will be created and returned.*/

__RV_pmd ***__RV_trie_get_trie_ref_pmd(void)
{
  static __RV_pmd **tbl = NULL;
  if(NULL == tbl)
    tbl = __RV_trie_create();
  return &tbl;
}

/*Get the trie storing pmds.
  If it does not exist, an empty trie will be created and returned.*/
 inline
__RV_pmd **__RV_trie_get_trie_pmd(void)
{
  return *__RV_trie_get_trie_ref_pmd();
}
/*===----------------------------------------------------------------------===//
//
//  This file is automatically generated for hash tables.
//
//===----------------------------------------------------------------------===*/

/*===----------------------------- list -----------------------------------===*/
#if defined __RV_use_hashtable
int __RV_list_find_pmd_ref(__RV_pmd **head_ref, __RV_ptr_addr ptra,
               __RV_pmd ***prev_ref);
int __RV_list_insert_pmd(__RV_pmd **head_ref, __RV_pmd *pmd,
               __RV_pmd ***prev_ref);
int __RV_list_insert_pmd_ptr(__RV_pmd **head_ref, __RV_ptr_addr ptra,
               __RV_pmd ***prev_ref);
int __RV_list_remove_pmd(__RV_pmd **head_ref, __RV_ptr_addr ptra,
               __RV_pmd ***prev_ref);
#endif
int __RV_list_find_fmd_ref(__RV_fmd **head_ref, __RV_func_addr func,
               __RV_fmd ***prev_ref);
int __RV_list_insert_fmd(__RV_fmd **head_ref, __RV_fmd *fmd,
               __RV_fmd ***prev_ref);
int __RV_list_insert_fmd_func(__RV_fmd **head_ref, __RV_func_addr func,
                unsigned char capacity, __RV_fmd ***prev_ref);
int __RV_list_remove_fmd(__RV_fmd **head_ref, __RV_func_addr func,
               __RV_fmd ***prev_ref);
/*===----------------------------- hashtbl --------------------------------===*/
size_t           __RV_hashtbl_hash(size_t key, size_t capacity);
__RV_hashtbl  *__RV_hashtbl_create(size_t capacity);
/*===----------------------------- hashtbl for pmd ------------------------===*/
#if defined __RV_use_hashtable
void             __RV_hashtbl_free_slots_pmd(__RV_hashtbl *tbl);
void             __RV_hashtbl_free_pmd(__RV_hashtbl *tbl);
__RV_pmd      *__RV_hashtbl_find_pmd(__RV_hashtbl *tbl, __RV_ptr_addr ptra);
__RV_pmd      *__RV_hashtbl_insert_pmd(__RV_hashtbl *tbl, __RV_pmd *pmd);
__RV_pmd      *__RV_hashtbl_insert_pmd_ptr(__RV_hashtbl *tbl, __RV_ptr_addr ptra);
int              __RV_hashtbl_remove_pmd(__RV_hashtbl *tbl, __RV_ptr_addr ptra);
void             __RV_hashtbl_resize_pmd(__RV_hashtbl *tbl);
__RV_hashtbl  *__RV_hashtbl_transfer_pmds(__RV_hashtbl *old_tbl, __RV_hashtbl *new_tbl);
__RV_hashtbl **__RV_hashtbl_get_hashtbl_ref_pmd(void);
__RV_hashtbl  *__RV_hashtbl_get_hashtbl_pmd(void);
#endif
/*===----------------------------- hashtbl for fmd ------------------------===*/
void             __RV_hashtbl_free_slots_fmd(__RV_hashtbl *tbl);
void             __RV_hashtbl_free_fmd(__RV_hashtbl *tbl);
__RV_fmd      *__RV_hashtbl_find_fmd(__RV_hashtbl *tbl, __RV_func_addr func);
__RV_fmd      *__RV_hashtbl_insert_fmd(__RV_hashtbl *tbl, __RV_fmd *fmd);
__RV_fmd      *__RV_hashtbl_insert_fmd_func(__RV_hashtbl *tbl, __RV_func_addr func, unsigned char capacity);
int              __RV_hashtbl_remove_fmd(__RV_hashtbl *tbl, __RV_func_addr func);
void             __RV_hashtbl_resize_fmd(__RV_hashtbl *tbl);
__RV_hashtbl  *__RV_hashtbl_transfer_fmds(__RV_hashtbl *old_tbl, __RV_hashtbl *new_tbl);
__RV_hashtbl **__RV_hashtbl_get_hashtbl_ref_fmd(void);
__RV_hashtbl  *__RV_hashtbl_get_hashtbl_fmd(void);
#if defined __RV_use_one_fmd
/*Note that the hash table of fmd should not be replaced by an fmd buffer.
  For example, in a variadic function, the statements that get parameter values
  may be mixed with some function calls, thus the fmd buffer could be rewritten
  by these calls before finished reading the pmds of parameters. As a result,
  the pmds of parameters gotten after these calls are incorrect,
  and may lead to false positives or negatives.*/
__RV_fmd     **__RV_fmd_get_fmd_ref(void);
__RV_fmd      *__RV_fmd_get_fmd(void);
#endif

/*===----------------------------- list -----------------------------------===*/

#if defined __RV_use_hashtable

/*Find the pmd of the given pointer address in the linked list.
  If the pmd exists, it returns 1. Otherwise, it returns 0.
  The third parameter returns by pointer the address of the previous node's
  next pointer, after which the given pointer address could be inserted.*/

int __RV_list_find_pmd_ref(__RV_pmd **head_ref, __RV_ptr_addr ptra,
                             __RV_pmd ***prev_ref)
{
  __RV_pmd *cur;

  *prev_ref = head_ref;
  cur = **prev_ref;
  while(1)
  {
    if(cur == NULL)
      return 0;
    if(cur->ptra >= ptra)
      return cur->ptra == ptra;
    *prev_ref = &cur->next;
    cur = cur->next;
  }
}

/*Insert the given pmd to the linked list.
  If the pmd of the given pointer address already exists, it returns 0, and
  the existing pmd will be replaced and freed. Otherwise, it returns 1.*/
 inline
int __RV_list_insert_pmd(__RV_pmd **head_ref, __RV_pmd *pmd,
                           __RV_pmd ***prev_ref)
{
  __RV_pmd *cur;

  /*found: replace and free the existing pmd*/
  if(__RV_list_find_pmd_ref(head_ref, pmd->ptra, prev_ref))
  {
    cur = **prev_ref;
    pmd->next = cur->next;
    **prev_ref = pmd;
    __RV_pmd_free(cur);
    return 0;
  }
  /*not found: insert pmd*/
  pmd->next = **prev_ref;
  **prev_ref = pmd;
  return 1;
}

/*Insert a pmd of the given pointer address to the linked list.
  If the pmd of the given pointer address already exists, it returns 0.
  Otherwise, it returns 1. The third parameter returns by pointer
  the address of the previous node's next pointer.*/
 inline
int __RV_list_insert_pmd_ptr(__RV_pmd **head_ref, __RV_ptr_addr ptra,
                               __RV_pmd ***prev_ref)
{
  __RV_pmd *pmd;

  /*found: return 0*/
  if(__RV_list_find_pmd_ref(head_ref, ptra, prev_ref))
    return 0;
  /*not found: insert pmd*/
  pmd = __RV_pmd_create_null(ptra);
  pmd->next = **prev_ref;
  **prev_ref = pmd;
  return 1;
}

/*Remove and free the pmd of the given pointer address from the linked list.
  If a pmd is removed and freed, it returns 1. Otherwise, it returns 0.
  The third parameter returns by pointer the address of the previous node's
  next pointer.*/
 inline
int __RV_list_remove_pmd(__RV_pmd **head_ref, __RV_ptr_addr ptra,
                           __RV_pmd ***prev_ref)
{
  __RV_pmd *cur;

  /*not found: return 0*/
  if(!__RV_list_find_pmd_ref(head_ref, ptra, prev_ref))
    return 0;
  /*found: remove the existing pmd*/
  cur = **prev_ref;
  **prev_ref = cur->next;
  __RV_pmd_free(cur);
  return 1;
}

#endif


int __RV_list_find_fmd_ref(__RV_fmd **head_ref, __RV_func_addr func,
                             __RV_fmd ***prev_ref)
{
  __RV_fmd *cur;

  *prev_ref = head_ref;
  cur = **prev_ref;
  while(1)
  {
    if(cur == NULL)
      return 0;
    if(cur->func >= func)
      return cur->func == func;
    *prev_ref = &cur->next;
    cur = cur->next;
  }
}

 inline
int __RV_list_insert_fmd(__RV_fmd **head_ref, __RV_fmd *fmd,
                           __RV_fmd ***prev_ref)
{
  __RV_fmd *cur;

  /*found: replace and free the existing fmd*/
  if(__RV_list_find_fmd_ref(head_ref, fmd->func, prev_ref))
  {
    cur = **prev_ref;
    fmd->next = cur->next;
    **prev_ref = fmd;
    __RV_fmd_free(cur);
    return 0;
  }
  /*not found: insert fmd*/
  fmd->next = **prev_ref;
  **prev_ref = fmd;
  return 1;
}

 inline
int __RV_list_insert_fmd_func(__RV_fmd **head_ref, __RV_func_addr func,
                                unsigned char capacity, __RV_fmd ***prev_ref)
{
  __RV_fmd *fmd;

  /*found: return 0*/
  if(__RV_list_find_fmd_ref(head_ref, func, prev_ref))
  {
    __RV_fmd_resize_pmds(**prev_ref, capacity, 0);
    return 0;
  }
  /*not found: insert fmd*/
  fmd = __RV_fmd_create(func, capacity);
  fmd->next = **prev_ref;
  **prev_ref = fmd;
  return 1;
}

 inline
int __RV_list_remove_fmd(__RV_fmd **head_ref, __RV_func_addr func,
                           __RV_fmd ***prev_ref)
{
  __RV_fmd *cur;

  /*not found: return 0*/
  if(!__RV_list_find_fmd_ref(head_ref, func, prev_ref))
    return 0;
  /*found: remove the existing fmd*/
  cur = **prev_ref;
  **prev_ref = cur->next;
  __RV_fmd_free(cur);
  return 1;
}

/*===----------------------------- hashtbl --------------------------------===*/

/*Implement hash function hash_value % capacity = hash(key) % capacity, where
  hash_value % capacity is used as the slot index of the key.*/
 inline
size_t __RV_hashtbl_hash(size_t key, size_t capacity)
{
  /*This function ensures that hashCodes that differ only by
    constant multiples at each bit position have a bounded
    number of collisions (approximately 8 at default load factor).*/
  key = key ^ (key >> 20) ^ (key >> 12);
  key = key ^ (key >>  7) ^ (key >>  4);
  return key & (capacity - 1);
}

/*Create a hash table of the given capacity.*/

__RV_hashtbl *__RV_hashtbl_create(size_t capacity)
{
  size_t i;
  __RV_hashtbl *tbl = (__RV_hashtbl*)malloc(sizeof(__RV_hashtbl));
  if(NULL == tbl) return NULL;

  tbl->slots = (void **)malloc(capacity*sizeof(void *));
  if(NULL == tbl->slots)
  {
    free(tbl);
    return NULL;
  }

  for(i = 0; i < capacity; i++)
    tbl->slots[i] = NULL;
  tbl->capacity = capacity;
  tbl->size     = 0;
  tbl->count    = 0;
  return tbl;
}

/*===----------------------------- hashtbl for pmd ------------------------===*/

#if defined __RV_use_hashtable

/*Free the slots of a hash table storing pmds.*/

void __RV_hashtbl_free_slots_pmd(__RV_hashtbl *tbl)
{
  size_t i;
  __RV_pmd *pmd, *pmd1;
  if(tbl == NULL || tbl->slots == NULL) return;
  for(i = 0; i < tbl->capacity; i++)
  {
    pmd = (__RV_pmd *)tbl->slots[i];
    while(pmd != NULL)
    {
      pmd1 = pmd->next;
      __RV_pmd_free(pmd);
      pmd = pmd1;
    }
  }
  free(tbl->slots);
  tbl->slots    = NULL;
  tbl->capacity = 0;
  tbl->size     = 0;
  tbl->count    = 0;
}

/*Free a hash table storing pmds.*/
 inline
void __RV_hashtbl_free_pmd(__RV_hashtbl *tbl)
{
  if(tbl == NULL) return;
  __RV_hashtbl_free_slots_pmd(tbl);
  free(tbl);
}

/*Find the pmd of the given pointer address in the hash table.
  If the pmd does not exist, it returns NULL.*/
 inline
__RV_pmd *__RV_hashtbl_find_pmd(__RV_hashtbl *tbl, __RV_ptr_addr ptra)
{
  size_t index;
  __RV_pmd **prev;
  if(tbl == NULL) return NULL;

  index = __RV_hashtbl_hash((size_t)ptra, tbl->capacity);
  if(__RV_list_find_pmd_ref((__RV_pmd **)(tbl->slots + index), ptra, &prev))
    return *prev;
  return NULL;
}

/*Insert the given pmd to the hash table.
  If the pmd of the given pointer address already exists,
  the existing pmd will be replaced and freed.*/
 inline
__RV_pmd *__RV_hashtbl_insert_pmd(__RV_hashtbl *tbl, __RV_pmd *pmd)
{
  size_t index;
  __RV_pmd **prev;
  if(tbl == NULL || pmd == NULL) return NULL;

  index = __RV_hashtbl_hash((size_t)pmd->ptra, tbl->capacity);
  /*found: replace and free the existing pmd*/
  /*not found: insert pmd*/
  if(__RV_list_insert_pmd((__RV_pmd **)(tbl->slots + index), pmd, &prev))
  {
    if(prev == (__RV_pmd **)(tbl->slots + index) && (*prev)->next == NULL)
      tbl->size++;
    tbl->count++;
    __RV_hashtbl_resize_pmd(tbl);
  }
  return pmd;
}

/*Insert a pmd of the given pointer address to the hash table.
  If the pmd of the given pointer address already exists,
  the existing pmd will be returned.*/
 inline
__RV_pmd *__RV_hashtbl_insert_pmd_ptr(__RV_hashtbl *tbl, __RV_ptr_addr ptra)
{
  size_t index;
  __RV_pmd **prev, *cur;
  if(tbl == NULL) return NULL;

  index = __RV_hashtbl_hash((size_t)ptra, tbl->capacity);
  /*found: return the existing pmd*/
  if(!__RV_list_insert_pmd_ptr((__RV_pmd **)(tbl->slots + index), ptra, &prev))
    return *prev;
  /*not found: insert pmd*/
  cur = *prev; /*note: *prev != cur after resize*/
  if(prev == (__RV_pmd **)(tbl->slots + index) && cur->next == NULL)
    tbl->size++;
  tbl->count++;
  __RV_hashtbl_resize_pmd(tbl);
  return cur;
}

/*Remove and free the pmd of the given pointer address from the hash table.
  If a pmd is removed and freed, it returns 1. Otherwise, it returns 0.*/
 inline
int __RV_hashtbl_remove_pmd(__RV_hashtbl *tbl, __RV_ptr_addr ptra)
{
  size_t index;
  __RV_pmd **prev;
  if(tbl == NULL) return 0;

  index = __RV_hashtbl_hash((size_t)ptra, tbl->capacity);
  /*not found*/
  if(!__RV_list_remove_pmd((__RV_pmd **)(tbl->slots + index), ptra, &prev))
    return 0;
  /*found: remove the existing pmd*/
  if(prev == (__RV_pmd **)(tbl->slots + index) && *prev == NULL)
    tbl->size--;
  tbl->count--;
  return 1;
}

/*Resize a hash table storing pmds.
  If resizing is needed, the capacity of the hash table is doubled.
  Note that the pmds in the hash table will be re-ordered.*/
 inline
void __RV_hashtbl_resize_pmd(__RV_hashtbl *tbl)
{
  __RV_hashtbl *new_tbl;

  if(tbl == NULL || (tbl->count <= 3 * tbl->size))
    return;

  new_tbl = __RV_hashtbl_create(2*(tbl->capacity));
  new_tbl = __RV_hashtbl_transfer_pmds(tbl, new_tbl);
  free(tbl->slots);
  tbl->slots    = new_tbl->slots;
  tbl->capacity = new_tbl->capacity;
  tbl->size     = new_tbl->size;
  tbl->count    = new_tbl->count;
  free(new_tbl);
}

/*Transfer all pmds of an old hash table to a new hash table.
  It returns the hash table containing all these pmds.
  If new_tbl is NULL, it returns old_tbl.*/

__RV_hashtbl *__RV_hashtbl_transfer_pmds(__RV_hashtbl *old_tbl,
                                             __RV_hashtbl *new_tbl)
{
  size_t i;
  __RV_pmd *pmd, *pmd1;

  if(NULL == new_tbl) return old_tbl;
  if(NULL == old_tbl) return new_tbl;

  for(i = 0; i < old_tbl->capacity; i++)
  {
    pmd = (__RV_pmd *)old_tbl->slots[i];
    /*Remove the list of pmds from old_tbl.*/
    old_tbl->slots[i] = NULL;
    while(pmd != NULL)
    {
      pmd1 = pmd->next;
      pmd->next = NULL;
      __RV_hashtbl_insert_pmd(new_tbl, pmd);
      pmd = pmd1;
    }
  }
  old_tbl->size  = 0;
  old_tbl->count = 0;
  return new_tbl;
}

/*Get the reference of the hash table storing pmds.
  If it does not exist, an empty hash table will be created and returned.*/

__RV_hashtbl **__RV_hashtbl_get_hashtbl_ref_pmd(void)
{
  static __RV_hashtbl *tbl = NULL;
  if(NULL == tbl)
    tbl = __RV_hashtbl_create(1024);
  return &tbl;
}

/*Get the hash table storing pmds.
  If it does not exist, an empty hash table will be created and returned.*/
 inline
__RV_hashtbl *__RV_hashtbl_get_hashtbl_pmd(void)
{
  return *__RV_hashtbl_get_hashtbl_ref_pmd();
}

#endif

/*===----------------------------- hashtbl for fmd ------------------------===*/


void __RV_hashtbl_free_slots_fmd(__RV_hashtbl *tbl)
{
  size_t i;
  __RV_fmd *fmd, *fmd1;
  if(tbl == NULL || tbl->slots == NULL) return;
  for(i = 0; i < tbl->capacity; i++)
  {
    fmd = (__RV_fmd *)tbl->slots[i];
    while(fmd != NULL)
    {
      fmd1 = fmd->next;
      __RV_fmd_free(fmd);
      fmd = fmd1;
    }
  }
  free(tbl->slots);
  tbl->slots    = NULL;
  tbl->capacity = 0;
  tbl->size     = 0;
  tbl->count    = 0;
}

 inline
void __RV_hashtbl_free_fmd(__RV_hashtbl *tbl)
{
  if(tbl == NULL) return;
  __RV_hashtbl_free_slots_fmd(tbl);
  free(tbl);
}

 inline
__RV_fmd *__RV_hashtbl_find_fmd(__RV_hashtbl *tbl, __RV_func_addr func)
{
  size_t index;
  __RV_fmd **prev;
  if(tbl == NULL) return NULL;

  index = __RV_hashtbl_hash((size_t)func, tbl->capacity);
  if(__RV_list_find_fmd_ref((__RV_fmd **)(tbl->slots + index), func, &prev))
    return *prev;
  return NULL;
}

 inline
__RV_fmd *__RV_hashtbl_insert_fmd(__RV_hashtbl *tbl, __RV_fmd *fmd)
{
  size_t index;
  __RV_fmd **prev;
  if(tbl == NULL || fmd == NULL) return NULL;

  index = __RV_hashtbl_hash((size_t)fmd->func, tbl->capacity);
  /*found: replace and free the existing fmd*/
  /*not found: insert fmd*/
  if(__RV_list_insert_fmd((__RV_fmd **)(tbl->slots + index), fmd, &prev))
  {
    if(prev == (__RV_fmd **)(tbl->slots + index) && (*prev)->next == NULL)
      tbl->size++;
    tbl->count++;
    __RV_hashtbl_resize_fmd(tbl);
  }
  return fmd;
}

 inline
__RV_fmd *__RV_hashtbl_insert_fmd_func(__RV_hashtbl *tbl,
        __RV_func_addr func, unsigned char capacity)
{
  size_t index;
  __RV_fmd **prev, *cur;
  if(tbl == NULL) return NULL;

  index = __RV_hashtbl_hash((size_t)func, tbl->capacity);
  /*found: return the existing fmd*/
  if(!__RV_list_insert_fmd_func((__RV_fmd **)(tbl->slots + index), func, capacity, &prev))
  {
    __RV_fmd_resize_pmds(*prev, capacity, 0);
    return *prev;
  }
  /*not found: insert fmd*/
  cur = *prev; /*note: *prev != cur after resize*/
  if(prev == (__RV_fmd **)(tbl->slots + index) && cur->next == NULL)
    tbl->size++;
  tbl->count++;
  __RV_hashtbl_resize_fmd(tbl);
  return cur;
}

 inline
int __RV_hashtbl_remove_fmd(__RV_hashtbl *tbl, __RV_func_addr func)
{
  size_t index;
  __RV_fmd **prev;
  if(tbl == NULL) return 0;

  index = __RV_hashtbl_hash((size_t)func, tbl->capacity);
  /*not found*/
  if(!__RV_list_remove_fmd((__RV_fmd **)(tbl->slots + index), func, &prev))
    return 0;
  /*found: remove the existing fmd*/
  if(prev == (__RV_fmd **)(tbl->slots + index) && *prev == NULL)
    tbl->size--;
  tbl->count--;
  return 1;
}

 inline
void __RV_hashtbl_resize_fmd(__RV_hashtbl *tbl)
{
  __RV_hashtbl *new_tbl;

  if(tbl == NULL || (tbl->count <= 3 * tbl->size))
    return;

  new_tbl = __RV_hashtbl_create(2*(tbl->capacity));
  new_tbl = __RV_hashtbl_transfer_fmds(tbl, new_tbl);
  free(tbl->slots);
  tbl->slots    = new_tbl->slots;
  tbl->capacity = new_tbl->capacity;
  tbl->size     = new_tbl->size;
  tbl->count    = new_tbl->count;
  free(new_tbl);
}


__RV_hashtbl *__RV_hashtbl_transfer_fmds(__RV_hashtbl *old_tbl,
                                             __RV_hashtbl *new_tbl)
{
  size_t i;
  __RV_fmd *fmd, *fmd1;

  if(NULL == new_tbl) return old_tbl;
  if(NULL == old_tbl) return new_tbl;

  for(i = 0; i < old_tbl->capacity; i++)
  {
    fmd = (__RV_fmd *)old_tbl->slots[i];
    /*Remove the list of fmds from old_tbl.*/
    old_tbl->slots[i] = NULL;
    while(fmd != NULL)
    {
      fmd1 = fmd->next;
      fmd->next = NULL;
      __RV_hashtbl_insert_fmd(new_tbl, fmd);
      fmd = fmd1;
    }
  }
  old_tbl->size  = 0;
  old_tbl->count = 0;
  return new_tbl;
}


__RV_hashtbl **__RV_hashtbl_get_hashtbl_ref_fmd(void)
{
  static __RV_hashtbl *tbl = NULL;
  if(NULL == tbl)
    tbl = __RV_hashtbl_create(1024);
  return &tbl;
}

 inline
__RV_hashtbl *__RV_hashtbl_get_hashtbl_fmd(void)
{
  return *__RV_hashtbl_get_hashtbl_ref_fmd();
}

#if defined __RV_use_one_fmd

 inline
__RV_fmd **__RV_fmd_get_fmd_ref(void)
{
  static __RV_fmd *fmd = NULL;
  if(NULL == fmd)
    fmd = __RV_fmd_create(NULL, 32);
  return &fmd;
}

 inline
__RV_fmd *__RV_fmd_get_fmd(void)
{
  return *__RV_fmd_get_fmd_ref();
}

#endif
/*===----------------------------------------------------------------------===//
//
//  This file is automatically generated for the functions related to
//  the algorithm for the dynamic analysis of memory safety.
//
//===----------------------------------------------------------------------===*/

/*===----------------------------- utilities ------------------------------===*/
int __RV_sstrlen(const char *str);
/*===----------------------------- pmd_tbl --------------------------------===*/
__RV_pmd *__RV_pmd_tbl_create(__RV_ptr_addr ptra);
__RV_pmd *__RV_pmd_tbl_lookup(__RV_ptr_addr ptra);
void        __RV_pmd_tbl_print(__RV_ptr_addr ptra, const char *ptr_name);
__RV_pmd *__RV_pmd_tbl_update_sa(__RV_ptr_addr ptra, __RV_stat_node *snda,
                         const void *base, const void *bound);
void       *__RV_pmd_tbl_update_sa_ret(__RV_ptr_addr ptra, __RV_stat_node *snda,
                         const void *base, const void *bound, const void *ret);
__RV_pmd *__RV_pmd_tbl_update_ns(__RV_ptr_addr ptra, __RV_status stat,
                         const void *base, const void *bound);
__RV_pmd *__RV_pmd_tbl_update_pmd(__RV_ptr_addr ptra, const __RV_pmd *pmd);
void       *__RV_pmd_tbl_update_pmd_ret(__RV_ptr_addr ptra, const __RV_pmd *pmd,
                         const void *ret);
__RV_pmd *__RV_pmd_tbl_update_fpmd(__RV_ptr_addr ptra, const __RV_fmd_pmd *fpmd);
__RV_pmd *__RV_pmd_tbl_update_ptr(__RV_ptr_addr ptra, __RV_ptr_addr ptra1);
void       *__RV_pmd_tbl_update_ptr_ret(__RV_ptr_addr ptra, __RV_ptr_addr ptra1,
                         const void *ret);
__RV_pmd *__RV_pmd_tbl_update_null(__RV_ptr_addr ptra);
void        __RV_pmd_tbl_remove(__RV_ptr_addr ptra);
void        __RV_pmd_tbl_remove_pa(__RV_ptr_addr array, size_t size);
void        __RV_pmd_var_remove_pa(__RV_pmd *array, size_t size);

__RV_pmd *__RV_pmd_tbl_update_argv(int argc, char ***argv_addr, char * const argv[]);
__RV_pmd *__RV_pmd_var_update_argv(int argc, __RV_pmd *argv_pmd, char * const argv[]);
void        __RV_pmd_tbl_remove_argv(int argc, char ***argv_addr, char * const argv[]);
void        __RV_pmd_var_remove_argv(int argc, __RV_pmd *argv_pmd, char * const argv[]);
__RV_pmd *__RV_pmd_tbl_update_envp(char ***envp_addr, char **envp);
__RV_pmd *__RV_pmd_var_update_envp(__RV_pmd *envp_pmd, char **envp);
void        __RV_pmd_tbl_remove_envp(char ***envp_addr, char **envp);
void        __RV_pmd_var_remove_envp(__RV_pmd *envp_pmd, char **envp);
/*===----------------------------- fmd_tbl --------------------------------===*/
__RV_fmd     *__RV_fmd_tbl_create(__RV_func_addr func, unsigned char capacity);
__RV_fmd     *__RV_fmd_tbl_lookup(__RV_func_addr func);
__RV_fmd_pmd *__RV_fmd_tbl_lookup_fpmd(__RV_func_addr func, unsigned char i);
void            __RV_fmd_tbl_print(__RV_func_addr func, unsigned char i,
                             const char *func_name);
__RV_fmd     *__RV_fmd_tbl_update_pmd(__RV_func_addr func, unsigned char i,
                             const __RV_pmd *pmd);
void            __RV_fmd_tbl_remove(__RV_func_addr func);
/*===----------------------------- check ----------------------------------===*/
void *__RV_check_dpv(const __RV_pmd *pmd,
        const void *ptr, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);
long __RV_check_dpv_ss(const __RV_pmd *pmd,
        const void *ptr, long subscript, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);
void *__RV_check_dpfv(const __RV_pmd *pmd, const void *ptr,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);
void *__RV_check_dpc(const void *base, const void *bound,
        const void *ptr, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);
long __RV_check_dpc_ss(const void *base, const void *bound,
        const void *ptr, long subscript, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);
void *__RV_check_dpfc(const void *base, const void *bound, const void *ptr,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name);

/*===----------------------------- utilities ------------------------------===*/


int __RV_sstrlen(const char *str)
{
  int length = 0;
  while(str && *str != '\0')
  {
    length++;
    str++;
  }
  return length;
}

/*===----------------------------- pmd_tbl --------------------------------===*/

/*Create the pmd of the pointer address ptra.
  If the pmd of the given pointer address already exists,
  the existing pmd will be returned.*/
 inline
__RV_pmd *__RV_pmd_tbl_create(__RV_ptr_addr ptra)
{
#if defined __RV_use_trie
  __RV_pmd **tbl = __RV_trie_get_trie_pmd();
  return __RV_trie_insert_pmd_ptr(tbl, ptra);
#elif defined __RV_use_hashtable
  __RV_hashtbl *tbl = __RV_hashtbl_get_hashtbl_pmd();
  return __RV_hashtbl_insert_pmd_ptr(tbl, ptra);
#endif
}

/*Lookup for the pmd of the pointer address ptra.*/
 inline
__RV_pmd *__RV_pmd_tbl_lookup(__RV_ptr_addr ptra)
{
#if defined __RV_use_trie
  __RV_pmd **tbl = __RV_trie_get_trie_pmd();
  return __RV_trie_find_pmd(tbl, ptra);
#elif defined __RV_use_hashtable
  __RV_hashtbl *tbl = __RV_hashtbl_get_hashtbl_pmd();
  return __RV_hashtbl_find_pmd(tbl, ptra);
#endif
}

/*Print the pmd of the pointer address ptra.*/
 inline
void __RV_pmd_tbl_print(__RV_ptr_addr ptra, const char *ptr_name)
{
  __RV_pmd *pmd = __RV_pmd_tbl_lookup(ptra);
  if(!pmd)
    printf("The pmd of %s (addr = %p) does not exist.\n", ptr_name, (void*)ptra);
  else
  {
    printf("The pmd of %s (addr = %p) is [%p, %p), status = ",
           ptr_name, (void*)ptra, pmd->base, pmd->bound);
    if(!pmd->snda)
      printf("(null)\n");
    else
      printf("(%d, %lu)\n", pmd->snda->stat, pmd->snda->count);
  }
}

/*Update the pmd of the pointer address ptra, using the given status, base and bound.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
__RV_pmd *__RV_pmd_tbl_update_sa(__RV_ptr_addr ptra, __RV_stat_node *snda,
                         const void *base, const void *bound)
{
#if defined __RV_use_trie
  __RV_pmd **tbl = __RV_trie_get_trie_pmd();
  __RV_pmd *pmd = __RV_trie_insert_pmd_ptr(tbl, ptra);
#elif defined __RV_use_hashtable
  __RV_hashtbl *tbl = __RV_hashtbl_get_hashtbl_pmd();
  __RV_pmd *pmd = __RV_hashtbl_insert_pmd_ptr(tbl, ptra);
#endif
  __RV_pmd_c_snda(pmd, snda);
  pmd->base  = base;
  pmd->bound = bound;
  return pmd;
}

 inline
void *__RV_pmd_tbl_update_sa_ret(__RV_ptr_addr ptra, __RV_stat_node *snda,
                         const void *base, const void *bound, const void *ret)
{
  __RV_pmd_tbl_update_sa(ptra, snda, base, bound);
  return (void *)ret;
}

/*Update the pmd of the pointer address ptra, using the given stat, base and bound.
  Note that a new status is created from the given stat.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
__RV_pmd *__RV_pmd_tbl_update_ns(__RV_ptr_addr ptra, __RV_status stat,
                         const void *base, const void *bound)
{
  __RV_stat_node *snda = __RV_stat_node_create(stat, 0);
  return __RV_pmd_tbl_update_sa(ptra, snda, base, bound);
}

/*Update the pmd of the pointer address ptra,
  using the status, base and bound of the given pmd.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
__RV_pmd *__RV_pmd_tbl_update_pmd(__RV_ptr_addr ptra, const __RV_pmd *pmd)
{
  if(pmd == NULL)
    return __RV_pmd_tbl_update_sa(ptra, NULL, NULL, NULL);
  else
    return __RV_pmd_tbl_update_sa(ptra, pmd->snda, pmd->base, pmd->bound);
}

 inline
void *__RV_pmd_tbl_update_pmd_ret(__RV_ptr_addr ptra, const __RV_pmd *pmd,
                                   const void *ret)
{
  __RV_pmd_tbl_update_pmd(ptra, pmd);
  return (void *)ret;
}

/*Update the pmd of the pointer address ptra,
  using the status, base and bound of the given pmd in function pointer metadata.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
__RV_pmd *__RV_pmd_tbl_update_fpmd(__RV_ptr_addr ptra, const __RV_fmd_pmd *fpmd)
{
  if(fpmd == NULL)
    return __RV_pmd_tbl_update_sa(ptra, NULL, NULL, NULL);
  else
    return __RV_pmd_tbl_update_sa(ptra, fpmd->snda, fpmd->base, fpmd->bound);
}

/*Update the pmd of the pointer address ptra,
  using the status, base and bound of the pmd of the pointer address ptra1.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
__RV_pmd *__RV_pmd_tbl_update_ptr(__RV_ptr_addr ptra, __RV_ptr_addr ptra1)
{
  const __RV_pmd *pmd1 = __RV_pmd_tbl_lookup(ptra1);
  return __RV_pmd_tbl_update_pmd(ptra, pmd1);
}

 inline
void *__RV_pmd_tbl_update_ptr_ret(__RV_ptr_addr ptra, __RV_ptr_addr ptra1,
                                   const void *ret)
{
  __RV_pmd_tbl_update_ptr(ptra, ptra1);
  return (void *)ret;
}

/*Update the pmd of the pointer address ptra, using null.
  If the pmd does not exist, a new pmd is created and inserted.*/
 inline
__RV_pmd *__RV_pmd_tbl_update_null(__RV_ptr_addr ptra)
{
#if defined __RV_use_trie
  __RV_pmd **tbl = __RV_trie_get_trie_pmd();
  __RV_pmd *pmd = __RV_trie_insert_pmd_ptr(tbl, ptra);
#elif defined __RV_use_hashtable
  __RV_hashtbl *tbl = __RV_hashtbl_get_hashtbl_pmd();
  __RV_pmd *pmd = __RV_hashtbl_insert_pmd_ptr(tbl, ptra);
#endif
  __RV_pmd_set_null(pmd);
  return pmd;
}

/*Remove the pmd of the pointer address ptra.*/
 inline
void __RV_pmd_tbl_remove(__RV_ptr_addr ptra)
{
#if defined __RV_use_trie
  __RV_pmd **tbl = __RV_trie_get_trie_pmd();
  __RV_trie_remove_pmd(tbl, ptra);
#elif defined __RV_use_hashtable
  __RV_hashtbl *tbl = __RV_hashtbl_get_hashtbl_pmd();
  __RV_hashtbl_remove_pmd(tbl, ptra);
#endif
}

/*Remove the pmds of an array of pointers, e.g., void *array[size].*/

void __RV_pmd_tbl_remove_pa(__RV_ptr_addr array, size_t size)
{
  size_t i;
#if defined __RV_use_trie
  __RV_pmd **tbl = __RV_trie_get_trie_pmd();
  for(i = 0; i < size; i++)
    __RV_trie_remove_pmd(tbl, array+i);
#elif defined __RV_use_hashtable
  __RV_hashtbl *tbl = __RV_hashtbl_get_hashtbl_pmd();
  for(i = 0; i < size; i++)
    __RV_hashtbl_remove_pmd(tbl, array+i);
#endif
}


void __RV_pmd_var_remove_pa(__RV_pmd *array, size_t size)
{
  size_t i;
  for(i = 0; i < size; i++)
    __RV_pmd_set_null(array+i);
}

/*Update the pmds of an array of char pointers, e.g., char *argv[argc].
  If the pmd does not exist, a new pmd is created and inserted.*/

__RV_pmd *__RV_pmd_tbl_update_argv(int argc, char ***argv_addr, char * const argv[])
{
  int i;
  __RV_stat_node *sa = __RV_stat_node_create(__RV_stack, 0);
  for(i = 0; i < argc; i++)
    __RV_pmd_tbl_update_sa((__RV_ptr_addr)(argv+i), sa,
                             argv[i], argv[i] + __RV_sstrlen(argv[i]) + 1);
  return
    __RV_pmd_tbl_update_sa((__RV_ptr_addr)argv_addr, sa,
                             argv, argv + argc);
}


__RV_pmd *__RV_pmd_var_update_argv(int argc, __RV_pmd *argv_pmd, char * const argv[])
{
  int i;
  __RV_stat_node *sa = __RV_stat_node_create(__RV_stack, 0);
  for(i = 0; i < argc; i++)
    __RV_pmd_tbl_update_sa((__RV_ptr_addr)(argv+i), sa,
                             argv[i], argv[i] + __RV_sstrlen(argv[i]) + 1);
  return
    __RV_pmd_set(argv_pmd, sa, __RV_invalid, argv, argv + argc);
}

/*Remove the pmds of an array of char pointers, e.g., char *argv[argc].*/
 inline
void __RV_pmd_tbl_remove_argv(int argc, char ***argv_addr, char * const argv[])
{
  __RV_pmd_tbl_remove_pa((__RV_ptr_addr)argv, argc);
  __RV_pmd_tbl_remove((__RV_ptr_addr)argv_addr);
}

 inline
void __RV_pmd_var_remove_argv(int argc, __RV_pmd *argv_pmd, char * const argv[])
{
  __RV_pmd_tbl_remove_pa((__RV_ptr_addr)argv, argc);
  __RV_pmd_set_null(argv_pmd);
}

/*Update the pmds of an array of char pointers, e.g., char **envp.
  If the pmd does not exist, a new pmd is created and inserted.*/

__RV_pmd *__RV_pmd_tbl_update_envp(char ***envp_addr, char **envp)
{
  int i = 0;
  __RV_stat_node *sa = __RV_stat_node_create(__RV_stack, 0);
  while(envp[i] != NULL)
  {
    __RV_pmd_tbl_update_sa((__RV_ptr_addr)(envp+i), sa,
                             envp[i], envp[i] + __RV_sstrlen(envp[i]) + 1);
    i++;
  }
  return
    __RV_pmd_tbl_update_sa((__RV_ptr_addr)envp_addr, sa,
                             envp, envp + i + 1);
}


__RV_pmd *__RV_pmd_var_update_envp(__RV_pmd *envp_pmd, char **envp)
{
  int i = 0;
  __RV_stat_node *sa = __RV_stat_node_create(__RV_stack, 0);
  while(envp[i] != NULL)
  {
    __RV_pmd_tbl_update_sa((__RV_ptr_addr)(envp+i), sa,
                             envp[i], envp[i] + __RV_sstrlen(envp[i]) + 1);
    i++;
  }
  return
    __RV_pmd_set(envp_pmd, sa, __RV_invalid, envp, envp + i + 1);
}

/*Remove the pmds of an array of char pointers, e.g., char **envp,*/

void __RV_pmd_tbl_remove_envp(char ***envp_addr, char **envp)
{
  int i = 0;
  while(envp[i] != NULL)
  {
    __RV_pmd_tbl_remove((__RV_ptr_addr)(envp+i));
    i++;
  }
  __RV_pmd_tbl_remove((__RV_ptr_addr)envp_addr);
}


void __RV_pmd_var_remove_envp(__RV_pmd *envp_pmd, char **envp)
{
  int i = 0;
  while(envp[i] != NULL)
  {
    __RV_pmd_tbl_remove((__RV_ptr_addr)(envp+i));
    i++;
  }
  __RV_pmd_set_null(envp_pmd);
}

/*===----------------------------- fmd_tbl --------------------------------===*/

/*Create a function pointer metadata of the given capacity.*/
 inline
__RV_fmd *__RV_fmd_tbl_create(__RV_func_addr func, unsigned char capacity)
{
#if !defined __RV_use_one_fmd
  __RV_hashtbl *tbl = __RV_hashtbl_get_hashtbl_fmd();
  __RV_fmd *fmd = __RV_hashtbl_insert_fmd_func(tbl, func, capacity);
#elif defined __RV_use_one_fmd
  __RV_fmd *fmd = __RV_fmd_get_fmd();
  fmd->func = func;
  __RV_fmd_resize_pmds(fmd, capacity, 1);
#elif
  assert(false, "Unconsidered cases in __RV_fmd_tbl_create()!");
#endif
  __RV_fmd_set_null(fmd);
  return fmd;
}

/*Lookup for the function pointer metadata of the function address func.*/
 inline
__RV_fmd *__RV_fmd_tbl_lookup(__RV_func_addr func)
{
#if !defined __RV_use_one_fmd
  __RV_hashtbl *tbl = __RV_hashtbl_get_hashtbl_fmd();
  return __RV_hashtbl_find_fmd(tbl, func);
#elif defined __RV_use_one_fmd
  return __RV_fmd_get_fmd();
#elif
  assert(false, "Unconsidered cases in __RV_fmd_tbl_create()!");
#endif
}

/*Lookup for the i-th pmd in the function pointer metadata of the function address func.*/
 inline
__RV_fmd_pmd *__RV_fmd_tbl_lookup_fpmd(__RV_func_addr func, unsigned char i)
{
  const __RV_fmd *fmd = __RV_fmd_tbl_lookup(func);
  return __RV_fmd_get_fmd_pmd(fmd, i);
}

/*Print the i-th pmd in the function pointer metadata of the function address func.*/
 inline
void __RV_fmd_tbl_print(__RV_func_addr func, unsigned char i, const char *func_name)
{
  const __RV_fmd_pmd *fpmd = __RV_fmd_tbl_lookup_fpmd(func, i);
  if(!fpmd)
    printf("The fpmd of %s (param %d) does not exist.\n", func_name, i);
  else
  {
    printf("The fpmd of %s (param %d) is [%p, %p), status = ",
           func_name, i, fpmd->base, fpmd->bound);
    if(!fpmd->snda)
      printf("(null)\n");
    else
      printf("(%d, %lu)\n", fpmd->snda->stat, fpmd->snda->count);
  }
}

/*Update the i-th pmd in the function pointer metadata of the function address func,
  using the status, base and bound of the given pmd.*/
 inline
__RV_fmd *__RV_fmd_tbl_update_pmd(__RV_func_addr func, unsigned char i,
                                      const __RV_pmd *pmd)
{
  __RV_fmd *fmd = __RV_fmd_tbl_lookup(func);
  __RV_fmd_cp_pmd(fmd, i, pmd);
  return fmd;
}

/*Remove the function pointer metadata of the function address func.*/
 inline
void __RV_fmd_tbl_remove(__RV_func_addr func)
{
  __RV_fmd *fmd = __RV_fmd_tbl_lookup(func);
  __RV_fmd_set_null(fmd);
}

/*===----------------------------- check ----------------------------------===*/

/*Check deferences of pointer variables, e.g., *ptr.*/
 inline
void *__RV_check_dpv(const __RV_pmd *pmd,
        const void *ptr, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  __RV_status stat = __RV_pmd_get_stat(pmd);

  /*check pointer validity.*/
  if(ptr == NULL)
  {
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' is NULL. [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  /*check temporal errors, incl. object and sub-object.*/
#if defined __RV_use_trie
  if(pmd == NULL || pmd->pmdflag == 0)
#else
  if(pmd == NULL)
#endif
  {
#if defined _RV_NORANDOM
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
#else
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p, size = %lu) "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name, ptr, size);
#endif
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  if(stat == __RV_invalid)
  {
#if defined _RV_NORANDOM
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' "
           "points to an invalid object. "
           "[temporal error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
#else
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p, size = %lu) "
           "points to an invalid object (original block is [%p, %p)). "
           "[temporal error]\n",
            file_name, func_name, file_name, line, column, ptr_name, ptr, size, pmd->base, pmd->bound);
#endif
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  /*check segment errors.*/
  if(stat == __RV_function)
  {
#if defined _RV_NORANDOM
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' "
           "points to a function, not a data block. [segment error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
#else
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p, size = %lu) "
           "points to a function %p, not a data block. [segment error]\n",
            file_name, func_name, file_name, line, column, ptr_name, ptr, size, pmd->base);
#endif
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  /*check spatial errors.*/
  if(ptr < pmd->base || (char*)ptr + size > (char*)pmd->bound ||
                        (char*)ptr + size < (char*)ptr)
  {
#if defined _RV_NORANDOM
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' "
           "is out of the block. [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
#else
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p, size = %lu) "
           "is out of the block [%p, %p). [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name, ptr, size, pmd->base, pmd->bound);
#endif
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  return (void *)ptr;
}

/*Check deferences of pointer variables using subscripts, e.g., ptr[subscript].*/
 inline
long __RV_check_dpv_ss(const __RV_pmd *pmd,
        const void *ptr, long subscript, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  __RV_check_dpv(pmd, (char*)ptr + subscript * size, size,
                  file_name, func_name, line, column, ptr_name);
  return subscript;
}

/*Check deferences of function pointer variables, e.g., ptr() and (*ptr)().*/
 inline
void *__RV_check_dpfv(const __RV_pmd *pmd, const void *ptr,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  __RV_status stat = __RV_pmd_get_stat(pmd);

  /*check pointer validity.*/
  if(ptr == NULL)
  {
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' is NULL. [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  /*check temporal errors, incl. object and sub-object.*/
#if defined __RV_use_trie
  if(pmd == NULL || pmd->pmdflag == 0)
#else
  if(pmd == NULL)
#endif
  {
#if defined _RV_NORANDOM
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
#else
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p) "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name, ptr);
#endif
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  if(stat == __RV_invalid)
  {
#if defined _RV_NORANDOM
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' "
           "points to an invalid object. "
           "[temporal error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
#else
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p) "
           "points to an invalid object (original block is [%p, %p)). "
           "[temporal error]\n",
            file_name, func_name, file_name, line, column, ptr_name, ptr, pmd->base, pmd->bound);
#endif
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  /*check segment errors.*/
  if(stat != __RV_function && stat != __RV_library)
  {
#if defined _RV_NORANDOM
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' "
           "does not point to a function, but a data block. [segment error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
#else
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p) "
           "does not point to a function, but a data block [%p, %p). [segment error]\n",
            file_name, func_name, file_name, line, column, ptr_name, ptr, pmd->base, pmd->bound);
#endif
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  /*check spatial errors.*/
  if(ptr != pmd->base)
  {
#if defined _RV_NORANDOM
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' "
           "is not the address of a function. [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
#else
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p) "
           "is not the address of the function %p. [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name, ptr, pmd->base);
#endif
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  return (void *)ptr;
}

/*Check deferences of pointer constants, e.g., *ptr.*/
 inline
void *__RV_check_dpc(const void *base, const void *bound,
        const void *ptr, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  /*check pointer validity.*/
  if(ptr == NULL)
  {
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' is NULL. [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  /*check spatial errors.*/
  if(ptr < base || (char*)ptr + size > (char*)bound ||
                   (char*)ptr + size < (char*)ptr)
  {
#if defined _RV_NORANDOM
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' "
           "is out of the block. [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
#else
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p, size = %lu) "
           "is out of the block [%p, %p). [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name, ptr, size, base, bound);
#endif
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  return (void *)ptr;
}

/*Check deferences of pointer constants using subscripts, e.g., ptr[subscript].*/
 inline
long __RV_check_dpc_ss(const void *base, const void *bound,
        const void *ptr, long subscript, size_t size,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  __RV_check_dpc(base, bound, (char*)ptr + subscript * size, size,
                   file_name, func_name, line, column, ptr_name);
  return subscript;
}

/*Check deferences of function pointer constants, e.g., ((void (*)())100)().*/
 inline
void *__RV_check_dpfc(const void *base, const void *bound, const void *ptr,
        const char *file_name, const char *func_name,
        unsigned line, unsigned column, const char *ptr_name)
{
  /*check pointer validity.*/
  if(ptr == NULL)
  {
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' is NULL. [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  /*check spatial errors.*/
  if(ptr != base)
  {
#if defined _RV_NORANDOM
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' "
           "is not the address of a function. [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name);
#else
    fprintf(stderr, "%s: In function \'%s\':\n"
           "%s:%d:%d: error: dereferenced pointer \'%s\' (val = %p) "
           "is not the address of the function %p. [spatial error]\n",
            file_name, func_name, file_name, line, column, ptr_name, ptr, base);
#endif
    __RV_error_count++;
    __RV_memerr_action
    return (void *)ptr;
  }

  return (void *)ptr;
}
/*===----------------------------- bits/getopt_core.h ---------------------===*/
#include <getopt.h>

extern char *optarg;
extern int optind, opterr, optopt;
 int _RV_getopt(__RV_pmd *argv_pmd, __RV_pmd *options_pmd,
        int argc, char *const *argv, const char *options,
        const char *file_name, const char *func_name,
        unsigned a_line, unsigned a_col, const char *a_name,
        unsigned o_line, unsigned o_col, const char *o_name)
{
  int ret, i; __RV_pmd *pmd;
  __RV_check_dpv(options_pmd, options, __RV_sstrlen(options) + 1,
                   file_name, func_name, o_line, o_col, o_name);

  ret = getopt(argc, argv, options);

  /* getopt() may have re-ordered the pointer array argv[], so we need to
     re-compute the pmd of each pointer in the pointer array argv[]. */
  for(i = 0; i < argc; i++)
  {
    pmd = __RV_pmd_tbl_lookup((__RV_ptr_addr)&argv[i]);
    __RV_pmd_set_base(pmd, argv[i]);
    __RV_pmd_set_bound(pmd, argv[i] + __RV_sstrlen(argv[i]) + 1);
  }
  /* Update the pmd of the global pointer variable optarg. */
  if(optarg == NULL)
    __RV_pmd_tbl_remove((__RV_ptr_addr)&optarg);
  else
  {
    for(i = 0; i < argc; i++)
    {
      pmd = __RV_pmd_tbl_lookup((__RV_ptr_addr)&argv[i]);
      if(__RV_pmd_get_base(pmd) <= (void*)optarg &&
         (void*)optarg < __RV_pmd_get_bound(pmd))
        __RV_pmd_tbl_update_ptr((__RV_ptr_addr)&optarg, (__RV_ptr_addr)&argv[i]);
    }
  }

  __RV_pmd_free_null_ptr(argv_pmd);
  __RV_pmd_free_null_ptr(options_pmd);
  return ret;
}
/*===----------------------------- math.h ---------------------------------===*/
#include <math.h>

 double _RV_frexp(__RV_pmd *exponent_pmd,
        double x, int *exponent,
        const char *file_name, const char *func_name,
        unsigned e_line, unsigned e_col, const char *e_name)
{
  __RV_check_dpv(exponent_pmd, exponent, sizeof(int),
                   file_name, func_name, e_line, e_col, e_name);
  __RV_pmd_free_null_ptr(exponent_pmd);
  return frexp(x, exponent);
}

 double _RV_modf(__RV_pmd *integer_pmd,
        double x, double *integer,
        const char *file_name, const char *func_name,
        unsigned i_line, unsigned i_col, const char *i_name)
{
  __RV_check_dpv(integer_pmd, integer, sizeof(double),
                   file_name, func_name, i_line, i_col, i_name);
  __RV_pmd_free_null_ptr(integer_pmd);
  return modf(x, integer);
}
/*===----------------------------- stdio.h --------------------------------===*/
#include <stdio.h>

 int _RV__IO_getc(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return getc(fp);
}

 int _RV__IO_putc(__RV_pmd *fp_pmd,
        int ch, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return putc(ch, fp);
}

 void _RV_clearerr(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  clearerr(fp);
}

 int _RV_fclose(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_set_stat(fp_pmd, __RV_invalid);
  __RV_pmd_free_null_ptr(fp_pmd);
  return fclose(fp);
}

#if !defined _POSIX_C_SOURCE
 int _RV_fdopen(
        __RV_pmd *mode_pmd,
        int fd, const char *mode,
        const char *file_name, const char *func_name,
        unsigned m_line, unsigned m_col, const char *m_name)
{
  __RV_check_dpv(mode_pmd, mode, __RV_sstrlen(mode)+1,
                   file_name, func_name, m_line, m_col, m_name);
  __RV_pmd_free_null_ptr(mode_pmd);
  return fdopen(fd, mode);
}
#else
 FILE *_RV_fdopen(__RV_pmd *ret_pmd,
        __RV_pmd *mode_pmd,
        int fd, const char *mode,
        const char *file_name, const char *func_name,
        unsigned m_line, unsigned m_col, const char *m_name)
{
  FILE *ret;
  __RV_check_dpv(mode_pmd, mode, __RV_sstrlen(mode)+1,
                   file_name, func_name, m_line, m_col, m_name);

  ret = fdopen(fd, mode);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
  {
    __RV_pmd_set(ret_pmd, NULL, __RV_heap, ret, ret + 1);
    /*The pmds of the members of FILE are not updated.*/
  }

  __RV_pmd_free_null_ptr(mode_pmd);
  return ret;
}
#endif

 int _RV_feof(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return feof(fp);
}

 int _RV_ferror(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return ferror(fp);
}

 int _RV_fflush(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return fflush(fp);
}

 int _RV_fgetc(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return fgetc(fp);
}

 int _RV_fgetpos(__RV_pmd *fp_pmd, __RV_pmd *pos_pmd,
        FILE *fp, fpos_t *pos,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(pos_pmd, pos, sizeof(fpos_t),
                   file_name, func_name, p_line, p_col, p_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  __RV_pmd_free_null_ptr(pos_pmd);
  return fgetpos(fp, pos);
}

 char *_RV_fgets(__RV_pmd *ret_pmd,
        __RV_pmd *str_pmd, __RV_pmd *fp_pmd,
        char *str, int n, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  char *ret;
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);

  ret = fgets(str, n, fp);
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, str_pmd);

  __RV_pmd_free_null_ptr(str_pmd);
  __RV_pmd_free_null_ptr(fp_pmd);
  return ret;
}

 int _RV_fileno(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return fileno(fp);
}

 FILE *_RV_fopen(__RV_pmd *ret_pmd,
        __RV_pmd *filename_pmd, __RV_pmd *mode_pmd,
        const char *filename, const char *mode,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned m_line, unsigned m_col, const char *m_name)
{
  FILE *ret;
  __RV_check_dpv(filename_pmd, filename, __RV_sstrlen(filename)+1,
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(mode_pmd, mode, __RV_sstrlen(mode)+1,
                   file_name, func_name, m_line, m_col, m_name);

  ret = fopen(filename, mode);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
  {
    __RV_pmd_set(ret_pmd, NULL, __RV_heap, ret, ret + 1);
    /*The pmds of the members of FILE are not updated.*/
  }

  __RV_pmd_free_null_ptr(filename_pmd);
  __RV_pmd_free_null_ptr(mode_pmd);
  return ret;
}

 int _RV_fputc(__RV_pmd *fp_pmd,
        int ch, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return fputc(ch, fp);
}

 int _RV_fputs(__RV_pmd *str_pmd, __RV_pmd *fp_pmd,
        const char *str, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(str_pmd);
  __RV_pmd_free_null_ptr(fp_pmd);
  return fputs(str, fp);
}

 size_t _RV_fread(__RV_pmd *ptr_pmd, __RV_pmd *fp_pmd,
        void *ptr, size_t size, size_t nmemb, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(ptr_pmd, ptr, size * nmemb,
                   file_name, func_name, p_line, p_col, p_name);
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(ptr_pmd);
  __RV_pmd_free_null_ptr(fp_pmd);
  return fread(ptr, size, nmemb, fp);
}

 FILE *_RV_freopen(__RV_pmd *ret_pmd,
        __RV_pmd *filename_pmd, __RV_pmd *mode_pmd, __RV_pmd *fp_pmd,
        const char *filename, const char *mode, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned m_line, unsigned m_col, const char *m_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  FILE *ret;
  __RV_check_dpv(filename_pmd, filename, __RV_sstrlen(filename)+1,
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(mode_pmd, mode, __RV_sstrlen(mode)+1,
                   file_name, func_name, m_line, m_col, m_name);
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, p_line, p_col, p_name);

  ret = freopen(filename, mode, fp);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
  {
    __RV_pmd_set(ret_pmd, NULL, __RV_heap, ret, ret + 1);
    /*The pmds of the members of FILE are not updated.*/
  }

  __RV_pmd_free_null_ptr(filename_pmd);
  __RV_pmd_free_null_ptr(mode_pmd);
  __RV_pmd_free_null_ptr(fp_pmd);

  return ret;
}

 int _RV_fseek(__RV_pmd *fp_pmd,
        FILE *fp, long int offset, int whence,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return fseek(fp, offset, whence);
}

 int _RV_fsetpos(__RV_pmd *fp_pmd, __RV_pmd *pos_pmd,
        FILE *fp, const fpos_t *pos,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(pos_pmd, pos, sizeof(fpos_t),
                   file_name, func_name, p_line, p_col, p_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  __RV_pmd_free_null_ptr(pos_pmd);
  return fsetpos(fp, pos);
}

 long int _RV_ftell(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return ftell(fp);
}

 size_t _RV_fwrite(__RV_pmd *ptr_pmd, __RV_pmd *fp_pmd,
        const void *ptr, size_t size, size_t nmemb, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(ptr_pmd, ptr, size*nmemb,
                   file_name, func_name, p_line, p_col, p_name);
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(ptr_pmd);
  __RV_pmd_free_null_ptr(fp_pmd);
  return fwrite(ptr, size, nmemb, fp);
}

 int _RV_getc(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return getc(fp);
}

#if !defined __USE_ISOC11 || (defined __cplusplus && __cplusplus <= 201103L)
 char *_RV_gets(__RV_pmd *ret_pmd,
        __RV_pmd *str_pmd,
        char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
#if defined __GNUC__
  ret = fgets(str, 1024, stdin);
#else
  ret = gets(str);
#endif

  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, str_pmd);

  __RV_pmd_free_null_ptr(str_pmd);
  return str;
}
#else
 int _RV_gets(
        __RV_pmd *str_pmd,
        char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
#if defined __GNUC__
  int ret;
  str = fgets(str, 1024, stdin);
  if(str) ret = __RV_sstrlen(str);
  else ret = 0;
#else
  int ret = gets(str);
#endif

  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(str_pmd);
  return ret;
}
#endif

#if _POSIX_C_SOURCE >= 2 || /* Glibc <= 2.19: */ defined _BSD_SOURCE || defined _SVID_SOURCE
 int _RV_pclose(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_set_stat(fp_pmd, __RV_invalid);
  __RV_pmd_free_null_ptr(fp_pmd);
  return pclose(fp);
}
#endif

 void _RV_perror(__RV_pmd *str_pmd,
        const char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(str_pmd);
  perror(str);
}

#if _POSIX_C_SOURCE >= 2 || /* Glibc <= 2.19: */ defined _BSD_SOURCE || defined _SVID_SOURCE
 FILE *_RV_popen(__RV_pmd *ret_pmd,
        __RV_pmd *filename_pmd, __RV_pmd *mode_pmd,
        const char *filename, const char *mode,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned m_line, unsigned m_col, const char *m_name)
{
  FILE *ret;
  __RV_check_dpv(filename_pmd, filename, __RV_sstrlen(filename)+1,
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(mode_pmd, mode, __RV_sstrlen(mode)+1,
                   file_name, func_name, m_line, m_col, m_name);

  ret = popen(filename, mode);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
  {
    __RV_pmd_set(ret_pmd, NULL, __RV_heap, ret, ret + 1);
    /*The pmds of the members of FILE are not updated.*/
  }

  __RV_pmd_free_null_ptr(filename_pmd);
  __RV_pmd_free_null_ptr(mode_pmd);
  return ret;
}
#endif

 int _RV_putc(__RV_pmd *fp_pmd,
        int ch, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return putc(ch, fp);
}

 int _RV_puts(__RV_pmd *str_pmd,
        const char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(str_pmd);
  return puts(str);
}

 int _RV_remove(__RV_pmd *filename_pmd,
        const char *filename,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(filename_pmd, filename, __RV_sstrlen(filename)+1,
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(filename_pmd);
  return remove(filename);
}

 int _RV_rename(__RV_pmd *old_pmd, __RV_pmd *new_pmd,
        const char *old_filename, const char *new_filename,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned n_line, unsigned n_col, const char *n_name)
{
  __RV_check_dpv(old_pmd, old_filename, __RV_sstrlen(old_filename)+1,
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(new_pmd, new_filename, __RV_sstrlen(new_filename)+1,
                   file_name, func_name, n_line, n_col, n_name);
  __RV_pmd_free_null_ptr(old_pmd);
  __RV_pmd_free_null_ptr(new_pmd);
  return rename(old_filename, new_filename);
}

 void _RV_rewind(__RV_pmd *fp_pmd,
        FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  rewind(fp);
}

 void _RV_setbuf(__RV_pmd *fp_pmd, __RV_pmd *buffer_pmd,
        FILE *fp, char *buffer,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  if(buffer)
  __RV_check_dpv(buffer_pmd, buffer, 1,
                   file_name, func_name, b_line, b_col, b_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  __RV_pmd_free_null_ptr(buffer_pmd);
  setbuf(fp, buffer);
}

 int _RV_setvbuf(__RV_pmd *fp_pmd, __RV_pmd *buffer_pmd,
        FILE *fp, char *buffer, int mode, size_t size,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  if(buffer)
  __RV_check_dpv(buffer_pmd, buffer, size,
                   file_name, func_name, b_line, b_col, b_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  __RV_pmd_free_null_ptr(buffer_pmd);
  return setvbuf(fp, buffer, mode, size);
}

 FILE *_RV_tmpfile(__RV_pmd *ret_pmd)
{
  FILE *ret;
  ret = tmpfile();

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
  {
    __RV_pmd_set(ret_pmd, NULL, __RV_heap, ret, ret + 1);
    /*The pmds of the members of FILE are not updated.*/
  }

  return ret;
}

#if defined __GNUC__
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#endif
extern __RV_stat_node *__RV_static_sa;
 char *_RV_tmpnam(__RV_pmd *ret_pmd,
        __RV_pmd *str_pmd,
        char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);

  #if defined __GNUC__
  static char temp_file[L_tmpnam] = "tmp_XXXXXX";
  int fd = mkstemp(temp_file);
  unlink(temp_file);
  close(fd);
  if(str == NULL)
    ret = temp_file;
  else {
    strcpy(str, temp_file);
    ret = str;
  }
  #else
    ret = tmpnam(str);
  #endif

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_set(ret_pmd, __RV_static_sa, __RV_invalid,
                   ret, ret + __RV_sstrlen(ret) + 1);

  __RV_pmd_free_null_ptr(str_pmd);
  return ret;
}

 int _RV_ungetc(__RV_pmd *fp_pmd,
        int ch, FILE *fp,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  return ungetc(ch, fp);
}

#ifndef __RV_no_vasprintf
 int _RV_vasprintf(
        __RV_pmd *strp_pmd, __RV_pmd *fmt_pmd, __RV_pmd *ap_pmd,
        char **strp, const char *fmt, va_list ap,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned a_line, unsigned a_col, const char *a_name)
{
  int ret;
  __RV_check_dpv(strp_pmd, strp, sizeof(char*),
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(fmt_pmd, fmt, __RV_sstrlen(fmt)+1,
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(ap_pmd, ap, sizeof(va_list), /*sizeof(*va_list)*/
                   file_name, func_name, a_line, a_col, a_name);

  ret = vasprintf(strp, fmt, ap);

  __RV_pmd_tbl_update_ns((__RV_ptr_addr)strp, __RV_heap,
                 *strp, *strp + __RV_sstrlen(*strp) + 1);

  __RV_pmd_free_null_ptr(strp_pmd);
  __RV_pmd_free_null_ptr(fmt_pmd);
  __RV_pmd_free_null_ptr(ap_pmd);
  return ret;
}
#endif

 int _RV_vfprintf(
        __RV_pmd *fp_pmd, __RV_pmd *format_pmd, __RV_pmd *arg_pmd,
        FILE *fp, const char *format, va_list arg,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned r_line, unsigned r_col, const char *r_name,
        unsigned a_line, unsigned a_col, const char *a_name)
{
  __RV_check_dpv(fp_pmd, fp, sizeof(FILE),
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(format_pmd, format, __RV_sstrlen(format)+1,
                   file_name, func_name, r_line, r_col, r_name);
  __RV_check_dpv(arg_pmd, arg, sizeof(va_list), /*sizeof(*va_list)*/
                   file_name, func_name, a_line, a_col, a_name);
  __RV_pmd_free_null_ptr(fp_pmd);
  __RV_pmd_free_null_ptr(format_pmd);
  __RV_pmd_free_null_ptr(arg_pmd);
  return vfprintf(fp, format, arg);
}

 int _RV_vprintf(__RV_pmd *format_pmd, __RV_pmd *arg_pmd,
        const char *format, va_list arg,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned a_line, unsigned a_col, const char *a_name)
{
  __RV_check_dpv(format_pmd, format, __RV_sstrlen(format)+1,
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(arg_pmd, arg, sizeof(va_list), /*sizeof(*va_list)*/
                   file_name, func_name, a_line, a_col, a_name);
  __RV_pmd_free_null_ptr(format_pmd);
  __RV_pmd_free_null_ptr(arg_pmd);
  return vprintf(format, arg);
}

 int _RV_vsprintf(
        __RV_pmd *str_pmd, __RV_pmd *format_pmd, __RV_pmd *arg_pmd,
        char *str, const char *format, va_list arg,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned a_line, unsigned a_col, const char *a_name)
{
  char buffer[BUFSIZ];
  int ret;
  __RV_check_dpv(format_pmd, format, __RV_sstrlen(format)+1,
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(arg_pmd, arg, sizeof(va_list), /*sizeof(*va_list)*/
                   file_name, func_name, a_line, a_col, a_name);

  ret = vsprintf(buffer, format, arg);
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(buffer)+1,
                   file_name, func_name, s_line, s_col, s_name);
  strcpy(str, buffer);

  __RV_pmd_free_null_ptr(str_pmd);
  __RV_pmd_free_null_ptr(format_pmd);
  __RV_pmd_free_null_ptr(arg_pmd);
  return ret;
}

 void __RV_stdio_init_code(void)
{
  __RV_pmd_tbl_update_sa((__RV_ptr_addr)&stdin, __RV_static_sa, stdin, stdin + 1);
  __RV_pmd_tbl_update_sa((__RV_ptr_addr)&stdout, __RV_static_sa, stdout, stdout + 1);
  __RV_pmd_tbl_update_sa((__RV_ptr_addr)&stderr, __RV_static_sa, stderr, stderr + 1);
}

 void __RV_stdio_clear_code(void)
{
  __RV_pmd_tbl_remove((__RV_ptr_addr)&stdin);
  __RV_pmd_tbl_remove((__RV_ptr_addr)&stdout);
  __RV_pmd_tbl_remove((__RV_ptr_addr)&stderr);
}
/*===----------------------------- stdlib.h -------------------------------===*/
#include <stdlib.h>

 int _RV_atexit(__RV_pmd *func_pmd,
        void (*func)(void),
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpfv(func_pmd, func,
                    file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(func_pmd);
  return atexit(func);
}

 double _RV_atof(__RV_pmd *str_pmd,
        const char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(str_pmd);
  return atof(str);
}

 int _RV_atoi(__RV_pmd *str_pmd,
        const char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(str_pmd);
  return atoi(str);
}

 long int _RV_atol(__RV_pmd *str_pmd,
        const char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(str_pmd);
  return atol(str);
}

 void *_RV_bsearch(__RV_pmd *ret_pmd,
        __RV_pmd *key_pmd, __RV_pmd *base_pmd, __RV_pmd *compar_pmd,
        const void *key, const void *base, size_t num, size_t size, __compar_fn_t compar,
        const char *file_name, const char *func_name,
        unsigned k_line, unsigned k_col, const char *k_name,
        unsigned b_line, unsigned b_col, const char *b_name,
        unsigned c_line, unsigned c_col, const char *c_name)
{
  void *ret;
  __RV_check_dpv(key_pmd, key, size,
                   file_name, func_name, k_line, k_col, k_name);
  __RV_check_dpv(base_pmd, base, num*size,
                   file_name, func_name, b_line, b_col, b_name);
  __RV_check_dpfv(compar_pmd, compar,
                    file_name, func_name, c_line, c_col, c_name);

  /*Pass the pmds to the function pointer compar.*/
  __RV_fmd_tbl_create((__RV_func_addr)compar, 2);
  __RV_fmd_tbl_update_pmd((__RV_func_addr)compar, 0, key_pmd);
  __RV_fmd_tbl_update_pmd((__RV_func_addr)compar, 1, base_pmd);
  ret = bsearch(key, base, num, size, compar);
  __RV_fmd_tbl_remove((__RV_func_addr)compar);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, base_pmd);

  __RV_pmd_free_null_ptr(key_pmd);
  __RV_pmd_free_null_ptr(base_pmd);
  __RV_pmd_free_null_ptr(compar_pmd);

  return ret;
}

 void *_RV_calloc(__RV_pmd *ret_pmd,
        size_t n, size_t size)
{
  void *ret;
  ret = calloc(n, size);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_set(ret_pmd, NULL, __RV_heap,
                   ret, (char*)ret + n*size);

  return ret;
}

 void _RV_free(__RV_pmd *ptr_pmd,
        void *ptr,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  __RV_status stat = __RV_pmd_get_stat(ptr_pmd);
  const void *bound;
  void *p;
  char ptr_pmd_freed = 0;

  /*check pointer validity.*/
  if(ptr == NULL) /* free(NULL) is allowed */
    return;

  /*check temporal errors, incl. object and sub-object.*/
  if(ptr_pmd == NULL)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#if defined _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
           file_name, p_line, p_col, p_name);
#else
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' (val = %p) "
           "points to an invalid object (uninitialized). "
           "[spatial error]\n",
           file_name, p_line, p_col, p_name, ptr);
#endif
    __RV_error_count++;
    __RV_memerr_action
  }

  if(ptr_pmd && stat == __RV_invalid)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#if defined _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' "
           "points to an invalid object. "
           "[temporal error][illegal free]\n",
           file_name, p_line, p_col, p_name);
#else
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' (val = %p) "
           "points to an invalid object (original block is [%p, %p)). "
           "[temporal error][illegal free]\n",
           file_name, p_line, p_col, p_name, ptr, ptr_pmd->base, ptr_pmd->bound);
#endif
    __RV_error_count++;
    __RV_memerr_action
  }

  /*check segment errors.*/
  if(ptr_pmd && stat != __RV_heap && stat != __RV_library)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#if defined _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' "
           "does not point to a heap object. "
           "[segment error][illegal free]\n",
           file_name, p_line, p_col, p_name);
#else
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' (val = %p) "
           "does not point to a heap object (original block is [%p, %p)). "
           "[segment error][illegal free]\n",
           file_name, p_line, p_col, p_name, ptr, ptr_pmd->base, ptr_pmd->bound);
#endif
    __RV_error_count++;
    __RV_memerr_action
  }

  /*check spatial errors.*/
  if(ptr_pmd && ptr != ptr_pmd->base)
  {
    fprintf(stderr,"%s: In function \'%s\':\n", file_name, func_name);
#if defined _RV_NORANDOM
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' "
           "is not the base address. "
           "[spatial error][illegal free]\n",
           file_name, p_line, p_col, p_name);
#else
    fprintf(stderr,"%s:%d:%d: error: freed pointer \'%s\' (val = %p) "
           "is not the base address (original block is [%p, %p)). "
           "[spatial error][illegal free]\n",
           file_name, p_line, p_col, p_name, ptr, ptr_pmd->base, ptr_pmd->bound);
#endif
    __RV_error_count++;
    __RV_memerr_action
  }

  free(ptr);

  /* invalidate the status of the freed block. */
  if(ptr_pmd)
  {
    if(__RV_pmd_get_stat(ptr_pmd) == __RV_heap)
      __RV_pmd_set_stat(ptr_pmd, __RV_invalid);
  }

  /* remove all pmds of contained pointer members. */
  /* note that this depends on the bound of ptr_pmd. */
  bound = __RV_pmd_get_bound(ptr_pmd);
  for(p = ptr; p < bound; p = (char*)p + sizeof(void*))
  {
#if defined __RV_use_trie
    ptr_pmd_freed = 0;
#elif defined __RV_use_hashtable
    if(ptr_pmd && ptr_pmd->ptra == p) ptr_pmd_freed = 1; /* DO NOT free it later */
#endif
    __RV_pmd_tbl_remove((__RV_ptr_addr)p);
  }

  if(!ptr_pmd_freed)
  __RV_pmd_free_null_ptr(ptr_pmd);
}

 char *_RV_getenv(__RV_pmd *ret_pmd, __RV_pmd *name_pmd,
        const char *name,
        const char *file_name, const char *func_name,
        unsigned n_line, unsigned n_col, const char *n_name)
{
  char *ret;
  __RV_check_dpv(name_pmd, name, __RV_sstrlen(name)+1,
                   file_name, func_name, n_line, n_col, n_name);

  ret = getenv(name);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_set(ret_pmd, __RV_global_sa, __RV_invalid,
                   ret, ret + __RV_sstrlen(ret) + 1);

  __RV_pmd_free_null_ptr(name_pmd);
  return ret;
}

 void *_RV_malloc(__RV_pmd *ret_pmd,
        size_t size)
{
  void *ret;
  ret = malloc(size);

#if !defined _RV_NORANDOM && defined _RV_SHOWMALLOC
  printf("malloc: pointer (addr = %p) points to a new block [%p, %p).\n",
         ret, ret, (char*)ret + size);
#else
#endif

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_set(ret_pmd, NULL, __RV_heap,
                   ret, (char*)ret + size);

  return ret;
}

 int _RV_mblen(__RV_pmd *str_pmd,
        const char *str, size_t n,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(str_pmd);
  return mblen(str, n);
}

 size_t _RV_mbstowcs(__RV_pmd *pwcs_pmd, __RV_pmd *str_pmd,
        wchar_t *pwcs, const char *str, size_t n,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(pwcs_pmd, pwcs, sizeof(wchar_t),
                   file_name, func_name, p_line, p_col, p_name);
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(pwcs_pmd);
  __RV_pmd_free_null_ptr(str_pmd);
  return mbstowcs(pwcs, str, n);
}

 int _RV_mbtowc(__RV_pmd *pwc_pmd, __RV_pmd *str_pmd,
        wchar_t *pwc, const char *str, size_t n,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(pwc_pmd, pwc, sizeof(wchar_t),
                   file_name, func_name, p_line, p_col, p_name);
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(pwc_pmd);
  __RV_pmd_free_null_ptr(str_pmd);
  return mbtowc(pwc, str, n);
}



#ifdef __USE_GNU
 char *_RV_ptsname(__RV_pmd *ret_pmd, int fd)
{
  char *ret;
  ret = ptsname(fd);
  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_set(ret_pmd, __RV_static_sa, __RV_invalid,
                   ret, ret + __RV_sstrlen(ret) + 1);
  return ret;
}
#endif

 int _RV_putenv(__RV_pmd *str_pmd, char *__string,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(str_pmd, __string, __RV_sstrlen(__string) + 1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(str_pmd);
  return putenv(__string);
}

 void _RV_qsort(
        __RV_pmd *base_pmd, __RV_pmd *compar_pmd,
        void *base, size_t num, size_t size, __compar_fn_t compar,
        const char *file_name, const char *func_name,
        unsigned b_line, unsigned b_col, const char *b_name,
        unsigned c_line, unsigned c_col, const char *c_name)
{
  __RV_check_dpv(base_pmd, base, num*size,
                   file_name, func_name, b_line, b_col, b_name);
  __RV_check_dpfv(compar_pmd, compar,
                    file_name, func_name, c_line, c_col, c_name);

  /*Pass the pmds to the function pointer compar.*/
  __RV_fmd_tbl_create((__RV_func_addr)compar, 2);
  __RV_fmd_tbl_update_pmd((__RV_func_addr)compar, 0, base_pmd);
  __RV_fmd_tbl_update_pmd((__RV_func_addr)compar, 1, base_pmd);
  qsort(base, num, size, compar);
  __RV_fmd_tbl_remove((__RV_func_addr)compar);

  __RV_pmd_free_null_ptr(base_pmd);
  __RV_pmd_free_null_ptr(compar_pmd);
}

 void *_RV_realloc(__RV_pmd *ret_pmd, __RV_pmd *ptr_pmd,
        void *ptr, size_t newsize,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  char ptr_pmd_freed = 0;
  const void *bound;
  void *p; __RV_pmd *p_pmd;
  void *ret;
  ret = realloc(ptr, newsize);

  /*Extend the original memory block.*/
  if(ret == ptr)
  {
    __RV_pmd_set_stat (ptr_pmd, __RV_heap);
    __RV_pmd_set_base (ptr_pmd, ret);
    __RV_pmd_set_bound(ptr_pmd, (char*)ret + newsize);
    __RV_pmd_cp_pmd(ret_pmd, ptr_pmd);
  }
  /*Use another memory block.*/
  else
  {
    /* invalidate the status of the freed block. */
    if(ptr_pmd)
    {
      if(__RV_pmd_get_stat(ptr_pmd) == __RV_heap)
        __RV_pmd_set_stat(ptr_pmd, __RV_invalid);
    }

    /* copy all pmds of contained pointer members. */
    /* note that this depends on the bound of ptr_pmd. */
    bound = __RV_pmd_get_bound(ptr_pmd);
    for(p = ptr; p < bound; p = (char*)p + sizeof(void*))
    {
      p_pmd = __RV_pmd_tbl_lookup((__RV_ptr_addr)p);
      if(p_pmd)
      {
        __RV_pmd_tbl_update_pmd((__RV_ptr_addr)((char*)ret + ((char*)p - (char*)ptr)), p_pmd);
#if defined __RV_use_trie
        ptr_pmd_freed = 0;
#elif defined __RV_use_hashtable
        if(ptr_pmd && ptr_pmd->ptra == p) ptr_pmd_freed = 1; /* DO NOT free it later */
#endif
        __RV_pmd_tbl_remove((__RV_ptr_addr)p);
      }
    }

    /* initialize the status of the allocated block. */
    __RV_pmd_set(ret_pmd, NULL, __RV_heap,
                   ret, (char*)ret + newsize);
  }

  if(!ptr_pmd_freed)
  __RV_pmd_free_null_ptr(ptr_pmd);
  return ret;
}

 double _RV_strtod(__RV_pmd *str_pmd, __RV_pmd *endptr_pmd,
        const char *str, char **endptr,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned e_line, unsigned e_col, const char *e_name)
{
  double tmp;
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  if(endptr)
  __RV_check_dpv(endptr_pmd, endptr, sizeof(char*),
                   file_name, func_name, e_line, e_col, e_name);

  tmp = strtod(str, endptr);

  if(endptr)
    __RV_pmd_tbl_update_pmd((__RV_ptr_addr)endptr, str_pmd);

  __RV_pmd_free_null_ptr(str_pmd);
  __RV_pmd_free_null_ptr(endptr_pmd);

  return tmp;
}

 long int _RV_strtol(__RV_pmd *str_pmd, __RV_pmd *endptr_pmd,
        const char *str, char **endptr, int base,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned e_line, unsigned e_col, const char *e_name)
{
  long int tmp;
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  if(endptr)
  __RV_check_dpv(endptr_pmd, endptr, sizeof(char*),
                   file_name, func_name, e_line, e_col, e_name);

  tmp = strtol(str, endptr, base);

  if(endptr)
    __RV_pmd_tbl_update_pmd((__RV_ptr_addr)endptr, str_pmd);

  __RV_pmd_free_null_ptr(str_pmd);
  __RV_pmd_free_null_ptr(endptr_pmd);

  return tmp;
}

 unsigned long int _RV_strtoul(
        __RV_pmd *str_pmd, __RV_pmd *endptr_pmd,
        const char *str, char **endptr, int base,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned e_line, unsigned e_col, const char *e_name)
{
  unsigned long int tmp;
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  if(endptr)
  __RV_check_dpv(endptr_pmd, endptr, sizeof(char*),
                   file_name, func_name, e_line, e_col, e_name);

  tmp = strtoul(str, endptr, base);

  if(endptr)
    __RV_pmd_tbl_update_pmd((__RV_ptr_addr)endptr, str_pmd);

  __RV_pmd_free_null_ptr(str_pmd);
  __RV_pmd_free_null_ptr(endptr_pmd);

  return tmp;
}

 int _RV_system(__RV_pmd *str_pmd,
        const char *str,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(str_pmd);
  return system(str);
}

 size_t _RV_wcstombs(__RV_pmd *str_pmd, __RV_pmd *pwcs_pmd,
        char *str, const wchar_t *pwcs, size_t n,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(pwcs_pmd, pwcs, sizeof(wchar_t),
                   file_name, func_name, p_line, p_col, p_name);
  __RV_pmd_free_null_ptr(str_pmd);
  __RV_pmd_free_null_ptr(pwcs_pmd);
  return wcstombs(str, pwcs, n);
}

 int _RV_wctomb(__RV_pmd *str_pmd,
        char *str, wchar_t wchar,
        const char *file_name, const char *func_name,
        unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str)+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_pmd_free_null_ptr(str_pmd);
  return wctomb(str, wchar);
}
/*===----------------------------- string.h -------------------------------===*/
#include <string.h>

 void _RV_bcopy(__RV_pmd *src_pmd, __RV_pmd *dest_pmd,
                       const void *src, void *dest, size_t n,
                       const char *file_name, const char *func_name,
                       unsigned s_line, unsigned s_col, const char *s_name,
                       unsigned d_line, unsigned d_col, const char *d_name)
{
  char *p;
  __RV_pmd *p_pmd;

  __RV_check_dpv(src_pmd, src, n,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(dest_pmd, dest, n,
                   file_name, func_name, d_line, d_col, d_name);

  /* copy all pmds of contained pointer members. */
  if(dest < src && n > 0)
    for(p = (char*)((size_t)src & ~(size_t)7);
        p < (char*)src + n; p = p + sizeof(void*))
    {
      if(p < (char*)src) continue;
      p_pmd = __RV_pmd_tbl_lookup((__RV_ptr_addr)p);
      if(p_pmd)
      {
        __RV_pmd_tbl_update_pmd((__RV_ptr_addr)((char*)dest + (p - (char*)src)), p_pmd);
      }
    }
  else if(dest > src && n > 0)
    for(p = (char*)((size_t)((char*)src + n - 1) & ~(size_t)7);
        p >= (char*)src; p = p - sizeof(void*))
    {
      p_pmd = __RV_pmd_tbl_lookup((__RV_ptr_addr)p);
      if(p_pmd)
      {
        __RV_pmd_tbl_update_pmd((__RV_ptr_addr)((char*)dest + (p - (char*)src)), p_pmd);
      }
    }

  __RV_pmd_free_null_ptr(dest_pmd);
  __RV_pmd_free_null_ptr(src_pmd);
  bcopy(src, dest, n);
}

 void _RV_bzero(__RV_pmd *s_pmd,
                       void *s, size_t n,
                       const char *file_name, const char *func_name,
                       unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(s_pmd, s, n,
                   file_name, func_name, s_line, s_col, s_name);

  __RV_pmd_free_null_ptr(s_pmd);
  bzero(s, n);
}

#if defined __USE_MISC || defined __USE_XOPEN
 void *_RV_memccpy(__RV_pmd *ret_pmd,
                          __RV_pmd *dest_pmd, __RV_pmd *src_pmd,
                          void *dest, const void *src, int c, size_t n,
                          const char *file_name, const char *func_name,
                          unsigned d_line, unsigned d_col, const char *d_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  void *ret;
  __RV_check_dpv(src_pmd, src, n,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(dest_pmd, dest, n,
                   file_name, func_name, d_line, d_col, d_name);

  ret = memccpy(dest, src, c, n);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  __RV_pmd_free_null_ptr(src_pmd);
  __RV_pmd_free_null_ptr(dest_pmd);
  return ret;
}
#else
 int _RV_memccpy(__RV_pmd *dest_pmd, __RV_pmd *src_pmd,
                          void *dest, const void *src, int c, size_t n,
                          const char *file_name, const char *func_name,
                          unsigned d_line, unsigned d_col, const char *d_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(src_pmd, src, n,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(dest_pmd, dest, n,
                   file_name, func_name, d_line, d_col, d_name);

  __RV_pmd_free_null_ptr(src_pmd);
  __RV_pmd_free_null_ptr(dest_pmd);

  return memccpy(dest, src, c, n);
}
#endif

 void *_RV_memchr(__RV_pmd *ret_pmd, __RV_pmd *src_pmd,
                         const void *src, int c, size_t n,
                         const char *file_name, const char *func_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  void *ret;
  __RV_check_dpv(src_pmd, src, n,
                   file_name, func_name, s_line, s_col, s_name);

  ret = memchr(src, c, n);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, src_pmd);

  __RV_pmd_free_null_ptr(src_pmd);
  return ret;
}

 int _RV_memcmp(__RV_pmd *str1_pmd, __RV_pmd *str2_pmd,
                       const void *str1, const void *str2, size_t n,
                       const char *file_name, const char *func_name,
                       unsigned s1_line, unsigned s1_col, const char *s1_name,
                       unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  __RV_check_dpv(str1_pmd, str1, n,
                   file_name, func_name, s1_line, s1_col, s1_name);
  __RV_check_dpv(str2_pmd, str2, n,
                   file_name, func_name, s2_line, s2_col, s2_name);

  __RV_pmd_free_null_ptr(str1_pmd);
  __RV_pmd_free_null_ptr(str2_pmd);

  return memcmp(str1, str2, n);
}

 void *_RV_memcpy(__RV_pmd *ret_pmd,
                         __RV_pmd *dest_pmd, __RV_pmd *src_pmd,
                         void *dest, const void *src, size_t n,
                         const char *file_name, const char *func_name,
                         unsigned d_line, unsigned d_col, const char *d_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  void *ret;
  char *p;
  __RV_pmd *p_pmd;

  __RV_check_dpv(src_pmd, src, n,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(dest_pmd, dest, n,
                   file_name, func_name, d_line, d_col, d_name);

  ret = memcpy(dest, src, n);

  /* copy all pmds of contained pointer members. */
  if(dest < src && n > 0)
    for(p = (char*)((size_t)src & ~(size_t)7);
        p < (char*)src + n; p = p + sizeof(void*))
    {
      if(p < (char*)src) continue;
      p_pmd = __RV_pmd_tbl_lookup((__RV_ptr_addr)p);
      if(p_pmd)
      {
        __RV_pmd_tbl_update_pmd((__RV_ptr_addr)((char*)dest + (p - (char*)src)), p_pmd);
      }
    }
  else if(dest > src && n > 0)
    for(p = (char*)((size_t)((char*)src + n - 1) & ~(size_t)7);
        p >= (char*)src; p = p - sizeof(void*))
    {
      p_pmd = __RV_pmd_tbl_lookup((__RV_ptr_addr)p);
      if(p_pmd)
      {
        __RV_pmd_tbl_update_pmd((__RV_ptr_addr)((char*)dest + (p - (char*)src)), p_pmd);
      }
    }

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  __RV_pmd_free_null_ptr(src_pmd);
  __RV_pmd_free_null_ptr(dest_pmd);
  return ret;
}

 void *_RV_memmove(__RV_pmd *ret_pmd,
                          __RV_pmd *dest_pmd, __RV_pmd *src_pmd,
                          void *dest, const void *src, size_t n,
                          const char *file_name, const char *func_name,
                          unsigned d_line, unsigned d_col, const char *d_name,
                          unsigned s_line, unsigned s_col,  const char *s_name)
{
  void *ret;
  char *p;
  __RV_pmd *p_pmd;

  __RV_check_dpv(src_pmd, src, n,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(dest_pmd, dest, n,
                   file_name, func_name, d_line, d_col, d_name);

  ret = memmove(dest, src, n);

  /* copy all pmds of contained pointer members. */
  if(dest < src && n > 0)
    for(p = (char*)((size_t)src & ~(size_t)7);
        p < (char*)src + n; p = p + sizeof(void*))
    {
      if(p < (char*)src) continue;
      p_pmd = __RV_pmd_tbl_lookup((__RV_ptr_addr)p);
      if(p_pmd)
      {
        __RV_pmd_tbl_update_pmd((__RV_ptr_addr)((char*)dest + (p - (char*)src)), p_pmd);
      }
    }
  else if(dest > src && n > 0)
    for(p = (char*)((size_t)((char*)src + n - 1) & ~(size_t)7);
        p >= (char*)src; p = p - sizeof(void*))
    {
      p_pmd = __RV_pmd_tbl_lookup((__RV_ptr_addr)p);
      if(p_pmd)
      {
        __RV_pmd_tbl_update_pmd((__RV_ptr_addr)((char*)dest + (p - (char*)src)), p_pmd);
      }
    }

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  __RV_pmd_free_null_ptr(src_pmd);
  __RV_pmd_free_null_ptr(dest_pmd);
  return ret;
}

 void *_RV_memset(__RV_pmd *ret_pmd, __RV_pmd *str_pmd,
                         void *str, int c, size_t n,
                         const char *file_name, const char *func_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  void *ret;
  __RV_check_dpv(str_pmd, str, n,
                   file_name, func_name, s_line, s_col, s_name);

  ret = memset(str, c, n);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, str_pmd);

  __RV_pmd_free_null_ptr(str_pmd);
  return ret;
}

#ifdef __USE_MISC
#include <ctype.h>
 int _RV_strcasecmp(__RV_pmd *str1_pmd, __RV_pmd *str2_pmd,
        const char *str1, const char *str2,
        const char *file_name, const char *func_name,
        unsigned s1_line, unsigned s1_col, const char *s1_name,
        unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  unsigned i;
  for(i = 0; str1[i] != '\0' && str2[i] != '\0'; i++)
    if(tolower(str1[i]) != tolower(str2[i])) break;
  __RV_check_dpv(str1_pmd, str1, i + 1,
                   file_name, func_name, s1_line, s1_col, s1_name);
  __RV_check_dpv(str2_pmd, str2, i + 1,
                   file_name, func_name, s2_line, s2_col, s2_name);

  __RV_pmd_free_null_ptr(str2_pmd);
  __RV_pmd_free_null_ptr(str1_pmd);
  return strcasecmp(str1, str2);
}
#endif

 char *_RV_strcat(__RV_pmd *ret_pmd,
                         __RV_pmd *dest_pmd, __RV_pmd *src_pmd,
                         char *dest, const char *src,
                         const char *file_name, const char *func_name,
                         unsigned d_line, unsigned d_col, const char *d_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  __RV_check_dpv(dest_pmd, dest, __RV_sstrlen(dest) + __RV_sstrlen(src) + 1,
                   file_name, func_name, d_line, d_col, d_name);
  __RV_check_dpv(src_pmd, src, __RV_sstrlen(src) + 1,
                   file_name, func_name, s_line, s_col, s_name);

  ret = strcat(dest, src);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  __RV_pmd_free_null_ptr(dest_pmd);
  __RV_pmd_free_null_ptr(src_pmd);
  return ret;
}

 char *_RV_strchr(__RV_pmd *ret_pmd, __RV_pmd *src_pmd,
                         const char *src, int c,
                         const char *file_name, const char *func_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  unsigned i;
  for(i = 0; src[i] != '\0'; i++)
    if(src[i] == c) break;
  __RV_check_dpv(src_pmd, src, i + 1,
                   file_name, func_name, s_line, s_col, s_name);

  ret = strchr(src, c);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, src_pmd);

  __RV_pmd_free_null_ptr(src_pmd);
  return ret;
}

 int _RV_strcmp(__RV_pmd *str1_pmd, __RV_pmd *str2_pmd,
                       const char *str1, const char *str2,
                       const char *file_name, const char *func_name,
                       unsigned s1_line, unsigned s1_col, const char *s1_name,
                       unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  unsigned i;
  for(i = 0; str1[i] != '\0' && str2[i] != '\0'; i++)
    if(str1[i] != str2[i]) break;
  __RV_check_dpv(str1_pmd, str1, i + 1,
                   file_name, func_name, s1_line, s1_col, s1_name);
  __RV_check_dpv(str2_pmd, str2, i + 1,
                   file_name, func_name, s2_line, s2_col, s2_name);

  __RV_pmd_free_null_ptr(str2_pmd);
  __RV_pmd_free_null_ptr(str1_pmd);
  return strcmp(str1, str2);
}

 int _RV_strcoll(__RV_pmd *str1_pmd, __RV_pmd *str2_pmd,
                        const char *str1, const char *str2,
                        const char *file_name, const char *func_name,
                        unsigned s1_line, unsigned s1_col, const char *s1_name,
                        unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  __RV_check_dpv(str1_pmd, str1, __RV_sstrlen(str1) + 1,
                   file_name, func_name, s1_line, s1_col, s1_name);
  __RV_check_dpv(str2_pmd, str2, __RV_sstrlen(str2) + 1,
                   file_name, func_name, s2_line, s2_col, s2_name);

  __RV_pmd_free_null_ptr(str1_pmd);
  __RV_pmd_free_null_ptr(str2_pmd);
  return strcoll(str1, str2);
}

 char *_RV_strcpy(__RV_pmd *ret_pmd,
                         __RV_pmd *dest_pmd, __RV_pmd *src_pmd,
                         char *dest, const char *src,
                         const char *file_name, const char *func_name,
                         unsigned d_line, unsigned d_col, const char *d_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  __RV_check_dpv(src_pmd, src, __RV_sstrlen(src) + 1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(dest_pmd, dest, __RV_sstrlen(src) + 1,
                   file_name, func_name, d_line, d_col, d_name);

  ret = strcpy(dest, src);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  __RV_pmd_free_null_ptr(dest_pmd);
  __RV_pmd_free_null_ptr(src_pmd);
  return ret;
}

 size_t _RV_strcspn(__RV_pmd *str1_pmd, __RV_pmd *str2_pmd,
                   const char *str1, const char *str2,
                   const char *file_name, const char *func_name,
                   unsigned s1_line, unsigned s1_col, const char *s1_name,
                   unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  __RV_check_dpv(str1_pmd, str1, __RV_sstrlen(str1) + 1,
                   file_name, func_name, s1_line, s1_col, s1_name);
  __RV_check_dpv(str2_pmd, str2, __RV_sstrlen(str2) + 1,
                   file_name, func_name, s2_line, s2_col, s2_name);

  __RV_pmd_free_null_ptr(str1_pmd);
  __RV_pmd_free_null_ptr(str2_pmd);
  return strcspn(str1, str2);
}

#if _XOPEN_SOURCE >= 500 || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L || \
    /* Glibc <= 2.19: */ defined _BSD_SOURCE || defined _SVID_SOURCE
 char *_RV_strdup(__RV_pmd *ret_pmd, __RV_pmd *str_pmd,
                         const char *str,
                         const char *file_name, const char *func_name,
                         unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str) + 1,
                   file_name, func_name, s_line, s_col, s_name);

  ret = strdup(str);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_set(ret_pmd, NULL, __RV_heap,
                   ret, (char*)ret + __RV_sstrlen(str) + 1);

  __RV_pmd_free_null_ptr(str_pmd);
  return ret;
}
#endif

 char *_RV_strerror(__RV_pmd *ret_pmd,
                           int errnum)
{
  char *ret;
  ret = strerror(errnum);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_set(ret_pmd, __RV_global_sa, __RV_invalid,
                   ret, ret + __RV_sstrlen(ret) + 1);

  return ret;
}

 size_t _RV_strlen(__RV_pmd *str_pmd,
                          const char *str,
                          const char *file_name, const char *func_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str) + 1,
                   file_name, func_name, s_line, s_col, s_name);

  __RV_pmd_free_null_ptr(str_pmd);
  return strlen(str);
}

#ifdef __USE_MISC
 int _RV_strncasecmp(__RV_pmd *str1_pmd, __RV_pmd *str2_pmd,
        const char *str1, const char *str2, size_t n,
        const char *file_name, const char *func_name,
        unsigned s1_line, unsigned s1_col, const char *s1_name,
        unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  unsigned i;
  for(i = 0; i < n-1; i++)
    if(str1[i] == '\0' || str2[i] == '\0') break;
  __RV_check_dpv(str1_pmd, str1, i+1,
                   file_name, func_name, s1_line, s1_col, s1_name);
  __RV_check_dpv(str2_pmd, str2, i+1,
                   file_name, func_name, s2_line, s2_col, s2_name);

  __RV_pmd_free_null_ptr(str1_pmd);
  __RV_pmd_free_null_ptr(str2_pmd);
  return strncasecmp(str1, str2, n);
}
#endif

 char *_RV_strncat(__RV_pmd *ret_pmd,
                          __RV_pmd *dest_pmd, __RV_pmd *src_pmd,
                          char *dest, const char *src, size_t n,
                          const char *file_name, const char *func_name,
                          unsigned d_line, unsigned d_col, const char *d_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  int i;
  for(i = 0; i < n; i++)
    if(src[i] == '\0') break;
  __RV_check_dpv(dest_pmd, dest, __RV_sstrlen(dest) + i + 1,
                   file_name, func_name, d_line, d_col, d_name);
  __RV_check_dpv(src_pmd, src, (i == n) ? n : i+1,
                   file_name, func_name, s_line, s_col, s_name);

  ret = strncat(dest, src, n);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  __RV_pmd_free_null_ptr(src_pmd);
  __RV_pmd_free_null_ptr(dest_pmd);
  return ret;
}

 int _RV_strncmp(__RV_pmd *str1_pmd, __RV_pmd *str2_pmd,
                        const char *str1, const char *str2, size_t n,
                        const char *file_name, const char *func_name,
                        unsigned s1_line, unsigned s1_col, const char *s1_name,
                        unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  unsigned i;
  for(i = 0; i < n-1; i++)
    if(str1[i] == '\0' || str2[i] == '\0') break;
  __RV_check_dpv(str1_pmd, str1, i+1,
                   file_name, func_name, s1_line, s1_col, s1_name);
  __RV_check_dpv(str2_pmd, str2, i+1,
                   file_name, func_name, s2_line, s2_col, s2_name);

  __RV_pmd_free_null_ptr(str1_pmd);
  __RV_pmd_free_null_ptr(str2_pmd);
  return strncmp(str1, str2, n);
}

 char *_RV_strncpy(__RV_pmd *ret_pmd,
                          __RV_pmd *dest_pmd, __RV_pmd *src_pmd,
                          char *dest, const char *src, size_t n,
                          const char *file_name, const char *func_name,
                          unsigned d_line, unsigned d_col, const char *d_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  int i;
  for(i = 0; i < n-1; i++)
    if(src[i] == '\0') break;
  __RV_check_dpv(src_pmd, src, i+1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(dest_pmd, dest, n,
                   file_name, func_name, d_line, d_col, d_name);

  ret = strncpy(dest, src, n);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, dest_pmd);

  __RV_pmd_free_null_ptr(src_pmd);
  __RV_pmd_free_null_ptr(dest_pmd);
  return ret;
}

 char *_RV_strpbrk(__RV_pmd *ret_pmd,
                  __RV_pmd *str1_pmd, __RV_pmd *str2_pmd,
                  const char *str1, const char *str2,
                  const char *file_name, const char *func_name,
                  unsigned s1_line, unsigned s1_col, const char *s1_name,
                  unsigned s2_line, unsigned s2_col, const char *s2_name)
{
  char *ret;
  __RV_check_dpv(str1_pmd, str1, __RV_sstrlen(str1) + 1,
                   file_name, func_name, s1_line, s1_col, s1_name);
  __RV_check_dpv(str2_pmd, str2, __RV_sstrlen(str2) + 1,
                   file_name, func_name, s2_line, s2_col, s2_name);

  ret = strpbrk(str1, str2);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, str1_pmd);

  __RV_pmd_free_null_ptr(str2_pmd);
  __RV_pmd_free_null_ptr(str1_pmd);
  return ret;
}

 char *_RV_strrchr(__RV_pmd *ret_pmd, __RV_pmd *str_pmd,
                          const char *str, int c,
                          const char *file_name, const char *func_name,
                          unsigned s_line, unsigned s_col, const char *s_name)
{
  char *ret;
  __RV_check_dpv(str_pmd, str, __RV_sstrlen(str) + 1,
                   file_name, func_name, s_line, s_col, s_name);

  ret = strrchr(str, c);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, str_pmd);

  __RV_pmd_free_null_ptr(str_pmd);
  return ret;
}

#ifdef __USE_XOPEN2K8
 char *_RV_strsignal(__RV_pmd *ret_pmd, int __sig)
{
  char *ret;
  ret = strsignal(__sig);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_set(ret_pmd, __RV_library_sa, __RV_invalid,
                   ret, (char*)ret + __RV_sstrlen(ret) + 1);
  return ret;
}
#endif

 size_t _RV_strspn(__RV_pmd *str1_pmd, __RV_pmd *str2_pmd,
                          const char *str1, const char *str2,
                          const char *file_name, const char *func_name,
                          unsigned s_line, unsigned s_col, const char *s_name,
                          unsigned t_line, unsigned t_col, const char *t_name)
{
  __RV_check_dpv(str1_pmd, str1, __RV_sstrlen(str1) + 1,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(str2_pmd, str2, __RV_sstrlen(str2) + 1,
                   file_name, func_name, t_line, t_col, t_name);

  __RV_pmd_free_null_ptr(str1_pmd);
  __RV_pmd_free_null_ptr(str2_pmd);
  return strspn(str1, str2);
}

 char *_RV_strstr(__RV_pmd *ret_pmd,
                         __RV_pmd *haystack_pmd, __RV_pmd *needle_pmd,
                         const char *haystack, const char *needle,
                         const char *file_name, const char *func_name,
                         unsigned h_line, unsigned h_col, const char *h_name,
                         unsigned n_line, unsigned n_col, const char *n_name)
{
  char *ret;
  __RV_check_dpv(haystack_pmd, haystack, __RV_sstrlen(haystack) + 1,
                   file_name, func_name, h_line, h_col, h_name);
  __RV_check_dpv(needle_pmd, needle, __RV_sstrlen(needle) + 1,
                   file_name, func_name, n_line, n_col, n_name);

  ret = strstr(haystack, needle);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, haystack_pmd);

  __RV_pmd_free_null_ptr(haystack_pmd);
  __RV_pmd_free_null_ptr(needle_pmd);
  return ret;
}

 char *_RV_strtok(__RV_pmd *ret_pmd,
                         __RV_pmd *str_pmd, __RV_pmd *delim_pmd,
                         char *str, const char *delim,
                         const char *file_name, const char *func_name,
                         unsigned s_line, unsigned s_col, const char *s_name,
                         unsigned d_line, unsigned d_col, const char *d_name)
{
  /* Remember the pmd of the last non-null str */
  static __RV_pmd pmd = __RV_pmd_init_val;
  char *ret;
  if(str)
  {
    /* Remember the pmd of the last non-null str */
    __RV_pmd_cp_pmd(&pmd, str_pmd);
    __RV_check_dpv(str_pmd, str, __RV_sstrlen(str) + 1,
                     file_name, func_name, s_line, s_col, s_name);
  }
  __RV_check_dpv(delim_pmd, delim, __RV_sstrlen(delim) + 1,
                   file_name, func_name, d_line, d_col, d_name);

  ret = strtok(str, delim);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, &pmd);

  __RV_pmd_free_null_ptr(delim_pmd);
  __RV_pmd_free_null_ptr(str_pmd);
  return ret;
}

 size_t _RV_strxfrm(__RV_pmd *dest_pmd, __RV_pmd *src_pmd,
                           char *dest, const char *src, size_t n,
                           const char *file_name, const char *func_name,
                           unsigned d_line, unsigned d_col, const char *d_name,
                           unsigned s_line, unsigned s_col, const char *s_name)
{
  __RV_check_dpv(src_pmd, src, n,
                   file_name, func_name, s_line, s_col, s_name);
  __RV_check_dpv(dest_pmd, dest, n,
                   file_name, func_name, d_line, d_col, d_name);

  __RV_pmd_free_null_ptr(src_pmd);
  __RV_pmd_free_null_ptr(dest_pmd);
  return strxfrm(dest, src, n);
}
/*===----------------------------- sys/select.h ---------------------------===*/
#include <sys/select.h>

 int _RV_select(__RV_pmd *readfds_pmd, __RV_pmd *writefds_pmd,
        __RV_pmd *exceptfds_pmd, __RV_pmd *timeout_pmd,
        int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds,
        fd_set *__restrict __exceptfds, struct timeval *__restrict __timeout,
        const char *file_name, const char *func_name,
        unsigned r_line, unsigned r_col, const char *r_name,
        unsigned w_line, unsigned w_col, const char *w_name,
        unsigned e_line, unsigned e_col, const char *e_name,
        unsigned t_line, unsigned t_col, const char *t_name)
{
  __RV_check_dpv(readfds_pmd, __readfds, sizeof(fd_set),
                   file_name, func_name, r_line, r_col, r_name);
  __RV_check_dpv(writefds_pmd, __writefds, sizeof(fd_set),
                   file_name, func_name, w_line, w_col, w_name);
  __RV_check_dpv(exceptfds_pmd, __exceptfds, sizeof(fd_set),
                   file_name, func_name, e_line, e_col, e_name);
  if(__timeout)
    __RV_check_dpv(timeout_pmd, __timeout, sizeof(struct timeval),
                     file_name, func_name, t_line, t_col, t_name);

  __RV_pmd_free_null_ptr(readfds_pmd);
  __RV_pmd_free_null_ptr(writefds_pmd);
  __RV_pmd_free_null_ptr(exceptfds_pmd);
  __RV_pmd_free_null_ptr(timeout_pmd);
  return select(__nfds, __readfds, __writefds, __exceptfds, __timeout);
}
/*===----------------------------- unistd.h -------------------------------===*/
#include <unistd.h>

 int _RV_access(__RV_pmd *name_pmd,
        const char *__name, int __type,
        const char *file_name, const char *func_name,
        unsigned n_line, unsigned n_col, const char *n_name)
{
  __RV_check_dpv(name_pmd, __name, __RV_sstrlen(__name) + 1,
                   file_name, func_name, n_line, n_col, n_name);
  __RV_pmd_free_null_ptr(name_pmd);
  return access(__name, __type);
}

 int _RV_chdir(__RV_pmd *path_pmd, const char *__path,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  __RV_check_dpv(path_pmd, __path, __RV_sstrlen(__path) + 1,
                   file_name, func_name, p_line, p_col, p_name);
  __RV_pmd_free_null_ptr(path_pmd);
  return chdir(__path);
}

 int _RV_execv(__RV_pmd *path_pmd, __RV_pmd *argv_pmd,
        const char *__path, char *const __argv[],
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name,
        unsigned a_line, unsigned a_col, const char *a_name)
{
  int i = 0;
  __RV_check_dpv(path_pmd, __path, __RV_sstrlen(__path) + 1,
                   file_name, func_name, p_line, p_col, p_name);
  /* The array __argv[] must be NULL terminated. */
  while(__argv[i] != NULL)
  {
    __RV_check_dpv(__RV_pmd_tbl_lookup((__RV_ptr_addr)&__argv[i]),
                     __argv[i], __RV_sstrlen(__argv[i]) + 1,
                     file_name, func_name, a_line, a_col, a_name);
    i++;
  }
  __RV_check_dpv(argv_pmd, __argv, sizeof(char *) * (i + 1),
                   file_name, func_name, a_line, a_col, a_name);

  __RV_pmd_free_null_ptr(path_pmd);
  __RV_pmd_free_null_ptr(argv_pmd);
  return execv(__path, __argv);
}

 int _RV_execvp(__RV_pmd *file_pmd, __RV_pmd *argv_pmd,
        const char *__file, char *const __argv[],
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned a_line, unsigned a_col, const char *a_name)
{
  int i = 0;
  __RV_check_dpv(file_pmd, __file, __RV_sstrlen(__file) + 1,
                   file_name, func_name, f_line, f_col, f_name);
  /* The array __argv[] must be NULL terminated. */
  while(__argv[i] != NULL)
  {
    __RV_check_dpv(__RV_pmd_tbl_lookup((__RV_ptr_addr)&__argv[i]),
                     __argv[i], __RV_sstrlen(__argv[i]) + 1,
                     file_name, func_name, a_line, a_col, a_name);
    i++;
  }
  __RV_check_dpv(argv_pmd, __argv, sizeof(char *) * (i + 1),
                   file_name, func_name, a_line, a_col, a_name);

  __RV_pmd_free_null_ptr(file_pmd);
  __RV_pmd_free_null_ptr(argv_pmd);
  return execvp(__file, __argv);
}

 char *_RV_getcwd(__RV_pmd *ret_pmd, __RV_pmd *buf_pmd,
        char *buf, size_t size,
        const char *file_name, const char *func_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  char *ret;
  __RV_check_dpv(buf_pmd, buf, size,
                   file_name, func_name, b_line, b_col, b_name);

  ret = getcwd(buf, size);

  if(ret == NULL)
    __RV_pmd_set_null(ret_pmd);
  else
    __RV_pmd_cp_pmd(ret_pmd, buf_pmd);

  __RV_pmd_free_null_ptr(buf_pmd);
  return ret;
}

 int _RV_link(__RV_pmd *from_pmd, __RV_pmd *to_pmd,
        const char *__from, const char *__to,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name,
        unsigned t_line, unsigned t_col, const char *t_name)
{
  __RV_check_dpv(from_pmd, __from, __RV_sstrlen(__from) + 1,
                   file_name, func_name, f_line, f_col, f_name);
  __RV_check_dpv(to_pmd, __to, __RV_sstrlen(__to) + 1,
                   file_name, func_name, t_line, t_col, t_name);
  __RV_pmd_free_null_ptr(from_pmd);
  __RV_pmd_free_null_ptr(to_pmd);
  return link(__from, __to);
}

 int _RV_pipe(__RV_pmd *pipedes_pmd, int __pipedes[2],
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  __RV_check_dpv(pipedes_pmd, __pipedes, sizeof(int),
                   file_name, func_name, p_line, p_col, p_name);
  __RV_pmd_free_null_ptr(pipedes_pmd);
  return pipe(__pipedes);
}

 ssize_t _RV_read(__RV_pmd *buf_pmd,
        int fd, void *buf, size_t nbytes,
        const char *file_name, const char *func_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  __RV_check_dpv(buf_pmd, buf, nbytes,
                   file_name, func_name, b_line, b_col, b_name);
  __RV_pmd_free_null_ptr(buf_pmd);
  return read(fd, buf, nbytes);
}

 int _RV_rmdir(__RV_pmd *path_pmd, const char *__path,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  __RV_check_dpv(path_pmd, __path, __RV_sstrlen(__path) + 1,
                   file_name, func_name, p_line, p_col, p_name);
  __RV_pmd_free_null_ptr(path_pmd);
  return rmdir(__path);
}

 int _RV_truncate(__RV_pmd *file_pmd,
        const char *__file, __off_t __length,
        const char *file_name, const char *func_name,
        unsigned f_line, unsigned f_col, const char *f_name)
{
  __RV_check_dpv(file_pmd, __file, __RV_sstrlen(__file) + 1,
                   file_name, func_name, f_line, f_col, f_name);
  __RV_pmd_free_null_ptr(file_pmd);
  return truncate(__file, __length);
}

 int _RV_unlink(__RV_pmd *path_pmd,
        const char *path,
        const char *file_name, const char *func_name,
        unsigned p_line, unsigned p_col, const char *p_name)
{
  __RV_check_dpv(path_pmd, path, __RV_sstrlen(path) + 1,
                   file_name, func_name, p_line, p_col, p_name);
  __RV_pmd_free_null_ptr(path_pmd);
  return unlink(path);
}

 ssize_t _RV_write(__RV_pmd *buf_pmd,
        int fd, const void *buf, size_t nbytes,
        const char *file_name, const char *func_name,
        unsigned b_line, unsigned b_col, const char *b_name)
{
  __RV_check_dpv(buf_pmd, buf, nbytes,
                   file_name, func_name, b_line, b_col, b_name);
  __RV_pmd_free_null_ptr(buf_pmd);
  return write(fd, buf, nbytes);
}

 void __RV_unistd_init_code(void)
{
  extern char **environ;
  int i = 0;
  while(environ[i] != NULL)
  {
    __RV_pmd_tbl_update_sa((__RV_ptr_addr)(environ+i), __RV_global_sa,
                             environ[i], environ[i] + __RV_sstrlen(environ[i]) + 1);
    i++;
  }
  __RV_pmd_tbl_update_sa((__RV_ptr_addr)&environ, __RV_global_sa,
                           environ, environ + i + 1);
}

 void __RV_unistd_clear_code(void)
{
  extern char **environ;
  int i = 0;
  while(environ[i] != NULL)
  {
    __RV_pmd_tbl_remove((__RV_ptr_addr)(environ+i));
    i++;
  }
  __RV_pmd_tbl_remove((__RV_ptr_addr)&environ);
}
/*===----------------------------- call by ptr ----------------------------===*/
#include <stdarg.h>

 void __RV_call_wrapper_by_ptr(void (*fp)(void), ...)
{
  va_list vl;
  va_start(vl,fp);




  if(fp == (void (*)(void))malloc)
  {
    void **ret_addr = va_arg(vl, void **);
    __RV_pmd *ret_pmd = va_arg(vl, __RV_pmd *);
    size_t size = va_arg(vl, size_t);
    va_end(vl);

    *ret_addr = _RV_malloc(ret_pmd, size);
    return;
  }

  if(fp == (void (*)(void))realloc)
  {
    void **ret_addr = va_arg(vl, void **);
    __RV_pmd *ret_pmd = va_arg(vl, __RV_pmd *);
    __RV_pmd *ptr_pmd = va_arg(vl, __RV_pmd *);
    void *ptr = va_arg(vl, void *);
    unsigned int newsize = va_arg(vl, unsigned int);
    char *file_name = va_arg(vl, char *);
    char *func_name = va_arg(vl, char *);
    unsigned p_line = va_arg(vl, unsigned);
    unsigned p_col = va_arg(vl, unsigned);
    char *p_name = va_arg(vl, char *);
    va_end(vl);

    *ret_addr = _RV_realloc(ret_pmd, ptr_pmd, ptr, newsize, file_name, func_name, p_line, p_col, p_name);
    return;
  }

  if(fp == (void (*)(void))free)
  {
    __RV_pmd *ptr_pmd = va_arg(vl, __RV_pmd *);
    void *ptr = va_arg(vl, void *);
    char *file_name = va_arg(vl, char *);
    char *func_name = va_arg(vl, char *);
    unsigned p_line = va_arg(vl, unsigned);
    unsigned p_col = va_arg(vl, unsigned);
    char *p_name = va_arg(vl, char *);
    va_end(vl);

    _RV_free(ptr_pmd, ptr, file_name, func_name, p_line, p_col, p_name);
    return;
  }



  if(fp == (void (*)(void))memcpy)
  {
    void **ret_addr = va_arg(vl, void **);
    __RV_pmd *ret_pmd = va_arg(vl, __RV_pmd *);
    __RV_pmd *dest_pmd = va_arg(vl, __RV_pmd *);
    __RV_pmd *src_pmd = va_arg(vl, __RV_pmd *);
    void *dest = va_arg(vl, void *);
    const void *src = va_arg(vl, const void *);
    size_t n = va_arg(vl, size_t);
    const char *file_name = va_arg(vl, const char *);
    const char *func_name = va_arg(vl, const char *);
    unsigned d_line = va_arg(vl, unsigned);
    unsigned d_col = va_arg(vl, unsigned);
    const char *d_name = va_arg(vl, const char *);
    unsigned s_line = va_arg(vl, unsigned);
    unsigned s_col = va_arg(vl, unsigned);
    const char *s_name = va_arg(vl, const char *);
    va_end(vl);

    *ret_addr = _RV_memcpy(ret_pmd, dest_pmd, src_pmd, dest, src, n,
                  file_name, func_name, d_line, d_col, d_name, s_line, s_col, s_name);
    return;
  }


  /* unhandled call wrapper by pointer */
  fprintf(stderr, "error: unhandled call wrapper by pointer %p.\n", fp);
  abort();
}

int __RV_has_wrapper(void (*fp)(void))
{
  if(fp == (void (*)(void))access ||
     fp == (void (*)(void))atexit ||
     fp == (void (*)(void))atof ||
     fp == (void (*)(void))atoi ||
     fp == (void (*)(void))atol ||
     fp == (void (*)(void))bsearch ||
     fp == (void (*)(void))calloc ||
     fp == (void (*)(void))chdir ||
     fp == (void (*)(void))clearerr ||
     fp == (void (*)(void))execv ||
     fp == (void (*)(void))execvp ||
     fp == (void (*)(void))fclose ||
     fp == (void (*)(void))feof ||
     fp == (void (*)(void))ferror ||
     fp == (void (*)(void))fflush ||
     fp == (void (*)(void))fgetc ||
     fp == (void (*)(void))fgetpos ||
     fp == (void (*)(void))fgets ||
     fp == (void (*)(void))fopen ||
     fp == (void (*)(void))fprintf ||
     fp == (void (*)(void))fputc ||
     fp == (void (*)(void))fputs ||
     fp == (void (*)(void))fread ||
     fp == (void (*)(void))free ||
     fp == (void (*)(void))freopen ||
     fp == (void (*)(void))frexp ||
     fp == (void (*)(void))fscanf ||
     fp == (void (*)(void))fseek ||
     fp == (void (*)(void))fsetpos ||
     fp == (void (*)(void))ftell ||
     fp == (void (*)(void))fwrite ||
     fp == (void (*)(void))getc ||
     fp == (void (*)(void))getcwd ||
     fp == (void (*)(void))getenv ||
     fp == (void (*)(void))link ||
     fp == (void (*)(void))malloc ||
     fp == (void (*)(void))mblen ||
     fp == (void (*)(void))mbstowcs ||
     fp == (void (*)(void))mbtowc ||
     fp == (void (*)(void))memchr ||
     fp == (void (*)(void))memcmp ||
     fp == (void (*)(void))memcpy ||
     fp == (void (*)(void))memmove ||
     fp == (void (*)(void))memset ||
     fp == (void (*)(void))modf ||
     fp == (void (*)(void))perror ||
     fp == (void (*)(void))pipe ||
     fp == (void (*)(void))printf ||
     fp == (void (*)(void))putc ||
     fp == (void (*)(void))puts ||
     fp == (void (*)(void))qsort ||
     fp == (void (*)(void))read ||
     fp == (void (*)(void))realloc ||
     fp == (void (*)(void))remove ||
     fp == (void (*)(void))rename ||
     fp == (void (*)(void))rewind ||
     fp == (void (*)(void))rmdir ||
     fp == (void (*)(void))scanf ||
     fp == (void (*)(void))select ||
     fp == (void (*)(void))setbuf ||
     fp == (void (*)(void))setvbuf ||
     fp == (void (*)(void))sprintf ||
     fp == (void (*)(void))sscanf ||
     fp == (void (*)(void))strcat ||
     fp == (void (*)(void))strchr ||
     fp == (void (*)(void))strcmp ||
     fp == (void (*)(void))strcoll ||
     fp == (void (*)(void))strcpy ||
     fp == (void (*)(void))strcspn ||
     fp == (void (*)(void))strerror ||
     fp == (void (*)(void))strlen ||
     fp == (void (*)(void))strncat ||
     fp == (void (*)(void))strncmp ||
     fp == (void (*)(void))strncpy ||
     fp == (void (*)(void))strpbrk ||
     fp == (void (*)(void))strrchr ||
     fp == (void (*)(void))strspn ||
     fp == (void (*)(void))strstr ||
     fp == (void (*)(void))strtod ||
     fp == (void (*)(void))strtok ||
     fp == (void (*)(void))strtol ||
     fp == (void (*)(void))strtoul ||
     fp == (void (*)(void))strxfrm ||
     fp == (void (*)(void))system ||
     fp == (void (*)(void))tmpfile ||
     fp == (void (*)(void))ungetc ||
     fp == (void (*)(void))unlink ||
     fp == (void (*)(void))vasprintf ||
     fp == (void (*)(void))vfprintf ||
     fp == (void (*)(void))vprintf ||
     fp == (void (*)(void))vsprintf ||
     fp == (void (*)(void))wcstombs ||
     fp == (void (*)(void))wctomb ||
     fp == (void (*)(void))write)
    return 1;
  return 0;
}


void __RV_global_init_code(void) {
  __RV_function_sa = __RV_stat_node_create(__RV_function, 1);
  __RV_global_sa = __RV_stat_node_create(__RV_global, 1);
  __RV_static_sa = __RV_stat_node_create(__RV_static, 1);
  __RV_library_sa = __RV_stat_node_create(__RV_library, 1);
  __RV_stdio_init_code();
  __RV_unistd_init_code();
}

void __RV_global_clear_code(void) {
  __RV_unistd_clear_code();
  __RV_stdio_clear_code();
  __RV_stat_node_dec(__RV_library_sa);
  __RV_stat_node_dec(__RV_static_sa);
  __RV_stat_node_dec(__RV_global_sa);
  __RV_stat_node_dec(__RV_function_sa);
}

