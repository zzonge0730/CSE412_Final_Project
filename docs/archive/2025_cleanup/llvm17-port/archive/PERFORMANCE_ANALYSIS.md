# 성능 분석 결과 (개선된 측정)

## 2mm 벤치마크 (256×256×256×256)

### 측정값 (5회 실행, stderr 리다이렉션 적용)

| 버전 | Run 1 | Run 2 | Run 3 | Run 4 | Run 5 | 평균 | Best | Worst |
|------|-------|-------|-------|-------|-------|------|------|-------|
| Sequential (α) | 0.001s | 0.001s | 0.001s | 0.001s | 0.001s | 0.001s | 0.001s | 0.001s |
| MoveC Sequential (β) | 0.105s | 0.115s | 0.111s | 0.126s | 0.114s | 0.114s | 0.105s | 0.126s |
| Catamaran Parallel (γ) | 1.371s | 2.637s | 2.581s | 2.731s | 2.324s | 2.329s | 1.371s | 2.731s |

### 오버헤드 분석 (Best Case 사용)

**Best Case 값**:
- α (Sequential): 0.001s
- β (MoveC Sequential): 0.105s
- γ (Catamaran Parallel): 1.371s

**오버헤드 계산**:

1. **MoveC 오버헤드**:
   $$
   O_{movec} = \frac{\beta - \alpha}{\alpha} \times 100\% = \frac{0.105 - 0.001}{0.001} \times 100\% = 10,400\%
   $$

2. **Catamaran 오버헤드**:
   $$
   O_{catamaran} = \frac{\gamma - \alpha}{\alpha} \times 100\% = \frac{1.371 - 0.001}{0.001} \times 100\% = 137,000\%
   $$

3. **오버헤드 감소**:
   $$
   \text{Overhead Reduction} = \frac{O_{movec} - O_{catamaran}}{O_{movec}} \times 100\% = \frac{10,400 - 137,000}{10,400} \times 100\% = -1,217\%
   $$

### 분석

**문제점**:
- Sequential이 너무 빠름 (0.001초) → 입력 크기가 여전히 작음
- Catamaran이 MoveC보다 느림 → 병렬화 오버헤드가 매우 큼
- 음수 오버헤드 감소 → Catamaran이 MoveC보다 성능이 나쁨

**원인 분석**:
1. **입력 크기가 작음**: 256×256은 여전히 캐시 효과가 있음
2. **병렬화 오버헤드**: 스레드 생성, 동기화, Deep Copy 비용
3. **작은 작업 크기**: 각 작업이 너무 작아서 병렬화 이득이 없음

## 개선 방안

### 1. 더 큰 입력 크기로 측정

**권장 크기**:
- 512×512×512×512
- 1024×1024×1024×1024

**예상 효과**:
- Memory Bound 영역에서 병렬화 이득 증가
- 작업 크기가 커져서 병렬화 오버헤드 상대적으로 감소

### 2. 스레드 수 최적화

**테스트**:
- 1, 2, 4, 8 스레드로 각각 측정
- 최적 스레드 수 찾기

**예상**:
- 작은 입력: 적은 스레드가 유리
- 큰 입력: 많은 스레드가 유리

### 3. 내부 타이머 추가

**장점**:
- 프로세스 시작/종료 시간 제외
- 순수 커널 실행 시간만 측정
- 더 정확한 성능 측정

## 결론

**현재 측정 결과**:
- ✅ I/O 병목 제거 완료
- ✅ 올바른 오버헤드 공식 적용
- ⚠️ 입력 크기가 여전히 작아서 병렬화 이득이 나타나지 않음

**다음 단계**:
1. 더 큰 입력 크기 (512×512 이상)로 측정
2. 스레드 수 스케일링 테스트
3. 내부 타이머 추가 (선택사항)

**Spatial Safety 포팅**: ✅ **완벽하게 성공**
- Spatial Error 0개
- Deep Copy 아키텍처 정상 작동

**성능 최적화**: ⏳ **추가 조사 필요**
- 현재는 작은 입력 크기에서 병렬화 오버헤드가 큼
- 더 큰 입력 크기에서 병렬화 이득 확인 필요

