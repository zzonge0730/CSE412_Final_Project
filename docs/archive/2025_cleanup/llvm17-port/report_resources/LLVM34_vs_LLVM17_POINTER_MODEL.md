# LLVM 3.4 vs LLVM 17: 포인터 모델 변화와 기술적 난관

이 문서는 Catamaran 프로젝트를 LLVM 3.4(2013년 출시)에서 LLVM 17(2023년 출시)로 포팅하면서 겪은 기술적 난관의 핵심을 요약한 것입니다. 

두 버전 간의 가장 큰 차이는 **포인터 타입 시스템(Pointer Type System)**의 변화와 **메모리 분석(Memory Analysis)**의 엄격함에 있습니다.

## 1. LLVM 3.4: "느슨한" Typed Pointer 모델

LLVM 3.4 시절에는 포인터 자체가 타입 정보를 가지고 있었습니다 (**Typed Pointers**).

*   **특징**: `i32*`, `float*`, `struct.MyMetadata*`처럼 포인터만 봐도 이 메모리가 무엇을 가리키는지 컴파일러가 알 수 있었습니다.
*   **"느슨한" 이유**:
    *   **분석의 수월함**: 컴파일러가 타입 정보를 바탕으로 의존성 분석(Dependency Analysis)을 수행하기가 상대적으로 수월했습니다.
    *   **유연한 전달**: MoveC와 같은 도구는 메타데이터 포인터를 함수 인자로 넘길 때, 타입 캐스팅(bitcast)을 통해 비교적 자유롭게 데이터를 전달해도 컴파일러가 그 의도를 파악하고 연결해 줄 수 있었습니다.
    *   **Zero-copy 용이성**: 이로 인해 복잡한 메모리 복사 없이도 포인터만 넘겨주는 방식이 작동하기 쉬웠습니다.

## 2. LLVM 17: "엄격한" Opaque Pointer 및 메모리 모델

LLVM 15부터 도입되어 LLVM 17에서 강제된 **Opaque Pointers(불투명 포인터)**가 가장 큰 변화입니다.

*   **특징**: 모든 포인터는 타입 정보 없이 단순히 `ptr`로 통일됩니다. `i32*`든 `struct*`든 전부 `ptr`입니다.
*   **"엄격한" 이유**:
    *   **타입 정보 소실**: 컴파일러는 포인터만 보고 이것이 메타데이터인지 데이터인지 구별할 수 없습니다. 따라서 **메모리 의존성 분석(Memory Dependence Analysis)**이 매우 **보수적(Conservative)**으로 변합니다. 확실하지 않으면 의존성을 끊어버리거나 최적화를 포기합니다.
    *   **명시적 타입 요구**: 메모리를 읽거나(`load`) 쓸 때(`store`) 반드시 타입을 명시해야 하며, 주소 계산(`GEP`) 시에도 오프셋을 엄격하게 맞춰야 합니다.
    *   **엄격한 수명 관리 (Lifetime)**: 최신 컴파일러는 스택 메모리(`alloca`)의 수명 분석이 매우 정교합니다. 함수가 리턴되면 스택이 파괴된다는 것을 엄격하게 적용하므로, 스택에 있는 메타데이터의 주소만 슬쩍 다른 스레드로 넘기는 행위(Use-After-Return 위험)를 용납하지 않거나, 최적화 과정에서 문제를 일으킬 수 있습니다.

## 3. Catamaran 포팅에서의 구체적 의미

이러한 차이는 Catamaran 포팅 과정에서 다음과 같은 현상으로 나타났습니다:

*   **LLVM 3.4 (과거)**: 메타데이터가 스택에 있어도 포인터만 넘겨주면, 컴파일러의 분석기가 이를 추적하여 LiveIn 변수로 잘 잡아주었고, 별다른 복사 없이도 자식 스레드에서 접근이 가능했습니다 (운 좋게 작동했거나 분석기가 친절했음).
*   **LLVM 17 (현재)**:
    *   **자동 분석 실패**: Opaque Pointer 때문에 PDG(의존성 그래프) 분석기가 메타데이터와 사용처 간의 관계를 놓쳤습니다.
    *   **수명 문제 부각**: 스택에 있는 데이터를 포인터로만 넘기면 런타임에 쓰레기 값이 되거나 크래시가 발생합니다 (Use-After-Return).
*   **해결책 (Deep Copy)**: "엄격한" 환경을 만족시키기 위해, 데이터를 힙(Heap)에 완전히 복사(**Deep Copy**)하여 명시적으로 전달하는 무겁지만 확실한 방법을 도입해야 했습니다.

