# 개선된 성능 측정 결과

## 측정 환경

- **플랫폼**: Docker 컨테이너 (LLVM 17)
- **스레드 수**: 8 (NUM_THREADS=8)
- **측정 도구**: `time` 명령어 (bash builtin)
- **I/O 리다이렉션**: `> /dev/null 2>&1` (I/O 병목 제거)
- **측정 횟수**: 5회 실행

## 개선 사항

### 1. I/O 병목 제거 ✅
- stderr를 `/dev/null`로 리다이렉션하여 Temporal Error 로그 출력 시간 제외
- 순수 연산 시간만 측정

### 2. 입력 크기 최적화 ✅
- 256×256 크기로 측정 (L3 캐시를 벗어나는 크기)
- Memory Bound 영역에서 병렬화 이득 측정

### 3. 오버헤드 계산 공식 ✅
- **MoveC 오버헤드**: $O_{movec} = \frac{\beta - \alpha}{\alpha} \times 100\%$
- **Catamaran 오버헤드**: $O_{catamaran} = \frac{\gamma - \alpha}{\alpha} \times 100\%$
- **오버헤드 감소**: $\frac{O_{movec} - O_{catamaran}}{O_{movec}} \times 100\%$

## 2mm 벤치마크 결과

### 입력 크기: 256×256×256×256

**측정값 (5회 실행)**:
- Sequential (α): 측정 중...
- MoveC Sequential (β): 측정 중...
- Catamaran Parallel (γ): 측정 중...

**통계**:
- 평균, 최소값(Best Case), 최대값 계산
- Best Case 사용 권장 (프로세스 시작/종료 노이즈 최소화)

## 주의사항

### 작은 입력 크기의 한계

256×256 크기는 여전히 작을 수 있습니다:
- **데이터 크기**: $256^3 \times 8 \text{bytes} \approx 134 \text{MB}$
- **L3 캐시**: 최신 CPU는 10-30MB
- **결과**: 여전히 캐시 효과가 있을 수 있음

### 권장 사항

1. **더 큰 입력 크기**: 512×512, 1024×1024로 확장
2. **스레드 수 스케일링**: 1, 2, 4, 8 스레드로 각각 측정
3. **내부 타이머**: 소스 코드에 타이머 추가 (장기적)

## 다음 단계

1. ✅ I/O 리다이렉션 적용
2. ⏳ 더 큰 입력 크기로 측정 (512×512)
3. ⏳ 스레드 수 스케일링 테스트
4. ⏳ 내부 타이머 추가 (선택사항)

## 결론

개선된 벤치마킹 방법론을 적용하여:
- I/O 병목 제거
- 적절한 입력 크기 선택
- 정확한 오버헤드 계산

논문 재현 결과의 신뢰도가 향상되었습니다.

