# 성능 측정 결과

## 측정 환경

- **플랫폼**: Docker 컨테이너 (LLVM 17)
- **스레드 수**: 8 (NUM_THREADS=8)
- **측정 도구**: `/usr/bin/time -p`
- **측정 횟수**: 3회 실행 후 real time 기록

## 2mm 벤치마크 결과

### 입력 크기: 256×256×256×256

| 버전 | Run 1 | Run 2 | Run 3 | 평균 | 오버헤드 |
|------|-------|-------|-------|------|----------|
| Sequential (α) | 0.00s | 0.00s | 0.00s | 0.00s | baseline |
| MoveC Sequential (β) | 0.10s | 0.10s | 0.10s | 0.10s | +0.10s |
| Catamaran Parallel (γ) | 2.47s | 2.20s | 2.45s | 2.37s | +2.37s |

### 분석

- **MoveC 오버헤드 (β - α)**: 0.10초
- **병렬화 오버헤드 (γ - β)**: 2.27초
- **전체 오버헤드 (γ - α)**: 2.37초

**관찰**:
- Sequential이 매우 빠름 (0.00초) - 입력 크기가 상대적으로 작거나 최적화가 잘 됨
- MoveC 계측 오버헤드는 작음 (0.10초)
- 병렬화 오버헤드가 매우 큼 (2.27초) - 스레드 생성, 동기화, Deep Copy 비용

## gemm 벤치마크 결과

### 입력 크기: 256×256×256

| 버전 | Run 1 | Run 2 | Run 3 | 평균 | 오버헤드 |
|------|-------|-------|-------|------|----------|
| Sequential (α) | 0.02s | 0.02s | 0.02s | 0.02s | baseline |
| MoveC Sequential (β) | 0.05s | 0.05s | 0.05s | 0.05s | +0.03s |
| Catamaran Parallel (γ) | 57.06s | 50.41s | 51.36s | 52.94s | +52.92s |

### 분석

- **MoveC 오버헤드 (β - α)**: 0.03초
- **병렬화 오버헤드 (γ - β)**: 52.89초
- **전체 오버헤드 (γ - α)**: 52.92초

**관찰**:
- Sequential이 매우 빠름 (0.02초)
- MoveC 계측 오버헤드는 작음 (0.03초)
- 병렬화 오버헤드가 매우 큼 (52.89초) - gemm에서 더 심각함

## 주요 발견

### 1. 병렬화 오버헤드가 매우 큼

**가능한 원인**:
1. **작은 입력 크기**: 256×256은 병렬화 이득보다 오버헤드가 더 큼
2. **스레드 생성 비용**: 각 작업마다 스레드 생성/동기화
3. **Deep Copy 비용**: 메타데이터 구조체 복사 (하지만 이건 작을 것으로 예상)
4. **동기화 오버헤드**: join, barrier 등의 동기화 비용

### 2. 입력 크기 의존성

현재 측정한 입력 크기(256×256)는 병렬화에 최적화되지 않은 것으로 보입니다.

**권장**:
- 더 큰 입력 크기로 측정 (512×512, 1024×1024 등)
- 병렬화 이득이 오버헤드를 상쇄하는 임계점 찾기

### 3. 벤치마크별 차이

- **2mm**: 병렬화 오버헤드 2.27초
- **gemm**: 병렬화 오버헤드 52.89초

gemm에서 오버헤드가 더 큰 이유는 추가 조사가 필요합니다.

## 논문 재현 관점

### 원본 논문 결과

논문에서 보고한 오버헤드 감소:
- **MoveC**: 46-224% 오버헤드 감소

### 현재 결과

- **Spatial Error**: 0개 ✅ (완벽)
- **성능**: 병렬화 오버헤드가 매우 큼 ⚠️

**분석**:
- 논문의 결과는 더 큰 입력 크기에서 측정되었을 가능성이 높음
- 현재 측정은 작은 입력 크기로 인해 병렬화 오버헤드가 두드러짐
- 더 큰 입력 크기로 측정 필요

## 다음 단계

### 1. 더 큰 입력 크기로 측정

```bash
# 512×512 크기로 측정
./2mm 512 512 512 512 0
./MoveC-2mm 512 512 512 512 0
./CM-MoveC-2mm 512 512 512 512 0
```

### 2. 병렬화 이득 분석

- 스레드 수에 따른 성능 변화 측정
- 입력 크기별 병렬화 효율성 분석
- 오버헤드 구성 요소 분석 (스레드 생성, 동기화, Deep Copy)

### 3. 최적화 가능성

- 스레드 풀 재사용으로 스레드 생성 비용 감소
- 작업 크기 최적화
- 동기화 오버헤드 최소화

## 결론

**Spatial Safety 포팅**: ✅ **완벽하게 성공**
- Spatial Error 0개
- Deep Copy 아키텍처 정상 작동

**성능 측정**:
- 작은 입력 크기에서는 병렬화 오버헤드가 큼
- 더 큰 입력 크기로 측정하여 병렬화 이득 확인 필요
- 논문 재현을 위해서는 원본 논문의 입력 크기 확인 필요

